From 080b67c86b0bc392915e6a0cc1fd6bdea6c012a5 Mon Sep 17 00:00:00 2001
From: ci7lus <7887955+ci7lus@users.noreply.github.com>
Date: Fri, 20 Feb 2026 02:13:47 +0900
Subject: [PATCH] feat: Add stream_filter/dualmono

---
 modules/stream_filter/Makefile.am           |    3 +
 modules/stream_filter/dualmono.c            | 1991 +++++++++++++++++++
 modules/stream_filter/dualmono_aac_tables.h | 1451 ++++++++++++++
 modules/stream_filter/meson.build           |    5 +
 4 files changed, 3450 insertions(+)
 create mode 100644 modules/stream_filter/dualmono.c
 create mode 100644 modules/stream_filter/dualmono_aac_tables.h

diff --git a/modules/stream_filter/Makefile.am b/modules/stream_filter/Makefile.am
index 1d6a5499b2..d9c9ad7984 100644
--- a/modules/stream_filter/Makefile.am
+++ b/modules/stream_filter/Makefile.am
@@ -46,3 +46,6 @@ stream_filter_LTLIBRARIES += libadf_plugin.la

 libskiptags_plugin_la_SOURCES = stream_filter/skiptags.c
 stream_filter_LTLIBRARIES += libskiptags_plugin.la
+
+libdualmono_plugin_la_SOURCES = stream_filter/dualmono.c stream_filter/dualmono_aac_tables.h
+stream_filter_LTLIBRARIES += libdualmono_plugin.la
diff --git a/modules/stream_filter/dualmono.c b/modules/stream_filter/dualmono.c
new file mode 100644
index 0000000000..7fe3134c27
--- /dev/null
+++ b/modules/stream_filter/dualmono.c
@@ -0,0 +1,1991 @@
+/**
+MIT License
+
+Copyright (c) 2021 もにょ～ん
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+
+#ifdef HAVE_CONFIG_H
+# include "config.h"
+#endif
+
+#include <vlc_common.h>
+#include <vlc_plugin.h>
+#include <vlc_stream.h>
+#include <vlc_configuration.h>
+
+#include <assert.h>
+#include <inttypes.h>
+#include <string.h>
+
+#include "dualmono_aac_tables.h"
+
+#define TS_PACKET_SIZE 188
+#define TS_SYNC_BYTE 0x47
+
+#define DM_DEFAULT_PID1 0x1ff0
+#define DM_DEFAULT_PID2 0x1ff1
+
+#define DM_AAC_STREAM_TYPE 0x0f
+
+#define DM_MAX_WINDOW_GROUPS 8
+#define DM_MAX_SFB 64
+#define DM_MAX_SECT 64
+
+static int Open(vlc_object_t *);
+static void Close(vlc_object_t *);
+
+vlc_module_begin()
+    set_subcategory(SUBCAT_INPUT_STREAM_FILTER)
+    set_capability("stream_filter", 0)
+    add_shortcut("aacdualmono")
+    set_description(N_("MPEG-TS AAC dual-mono splitter"))
+    add_integer("aacdualmono-pid1", DM_DEFAULT_PID1,
+                N_("Mapped AAC PID for primary audio"),
+                N_("Output PID used for primary audio stream"))
+    add_integer("aacdualmono-pid2", DM_DEFAULT_PID2,
+                N_("Mapped AAC PID for secondary audio"),
+                N_("Output PID used for secondary audio stream"))
+    set_callbacks(Open, Close)
+vlc_module_end()
+
+typedef struct
+{
+    uint8_t *p;
+    size_t len;
+    size_t cap;
+} bytevec_t;
+
+typedef struct
+{
+    bool started;
+    bytevec_t buf;
+} pes_assembler_t;
+
+typedef struct
+{
+    uint8_t *p;
+    size_t bit_len;
+    size_t cap_bytes;
+} bitvec_t;
+
+typedef struct
+{
+    const uint8_t *p;
+    size_t bit_len;
+    size_t pos;
+} bitreader_t;
+
+typedef struct
+{
+    uint8_t profile;
+    uint8_t sf_index;
+    uint8_t private_bit;
+    uint8_t originality;
+    uint8_t home;
+    uint8_t copyrighted;
+    uint8_t copyright_id_start;
+    uint16_t buffer_fullness;
+    uint8_t mpeg_id;
+    uint8_t layer;
+    bool protection_absent;
+    uint8_t channel_configuration;
+    uint16_t frame_length;
+    uint8_t num_raw_data_blocks;
+} adts_header_t;
+
+typedef struct
+{
+    int window_sequence;
+    int max_sfb;
+    int num_window_groups;
+    int window_group_length[DM_MAX_WINDOW_GROUPS];
+    int num_sect[DM_MAX_WINDOW_GROUPS];
+    int sect_cb[DM_MAX_WINDOW_GROUPS][DM_MAX_SECT];
+    int sect_start[DM_MAX_WINDOW_GROUPS][DM_MAX_SECT];
+    int sect_end[DM_MAX_WINDOW_GROUPS][DM_MAX_SECT];
+    int sfb_cb[DM_MAX_WINDOW_GROUPS][DM_MAX_SFB];
+    int sect_sfb_offset[DM_MAX_WINDOW_GROUPS][DM_MAX_SFB + 1];
+} ics_parse_t;
+
+typedef struct
+{
+    bytevec_t in;
+    bytevec_t out;
+
+    bool upstream_eof;
+    bool flushed_eof;
+
+    int pmt_pid;
+    int aac_pid1;
+    int aac_pid2;
+
+    uint16_t mapped_pid1;
+    uint16_t mapped_pid2;
+
+    uint8_t pmt_cc;
+    uint8_t mapped_cc1;
+    uint8_t mapped_cc2;
+    uint8_t passthrough_cc1;
+    uint8_t passthrough_cc2;
+
+    bool dualmono_detected;
+    bool have_pmt_identity;
+    uint16_t pmt_program_number;
+    uint8_t pmt_version;
+
+    bool pmt_collecting;
+    size_t pmt_expected_len;
+    bytevec_t pmt_section;
+
+    pes_assembler_t pes1;
+    pes_assembler_t pes2;
+} stream_sys_t;
+
+static void bytevec_reset(bytevec_t *v);
+
+static void reset_dualmono_runtime_state(stream_sys_t *sys)
+{
+    sys->dualmono_detected = false;
+    sys->aac_pid1 = -1;
+    sys->aac_pid2 = -1;
+    sys->mapped_cc1 = 0;
+    sys->mapped_cc2 = 0;
+    sys->passthrough_cc1 = 0;
+    sys->passthrough_cc2 = 0;
+
+    sys->pes1.started = false;
+    sys->pes2.started = false;
+    bytevec_reset(&sys->pes1.buf);
+    bytevec_reset(&sys->pes2.buf);
+}
+
+static bool is_likely_mpegts(stream_t *s)
+{
+    const uint8_t *peek = NULL;
+    ssize_t n = vlc_stream_Peek(s->s, &peek, TS_PACKET_SIZE * 6 + (TS_PACKET_SIZE - 1));
+    if (n < TS_PACKET_SIZE * 4)
+        return false;
+
+    size_t avail = (size_t)n;
+    size_t limit = avail - TS_PACKET_SIZE * 3;
+    for (size_t off = 0; off < TS_PACKET_SIZE && off < limit; ++off)
+    {
+        if (peek[off] == TS_SYNC_BYTE &&
+            peek[off + TS_PACKET_SIZE] == TS_SYNC_BYTE &&
+            peek[off + TS_PACKET_SIZE * 2] == TS_SYNC_BYTE &&
+            peek[off + TS_PACKET_SIZE * 3] == TS_SYNC_BYTE)
+            return true;
+    }
+
+    return false;
+}
+
+static int bytevec_reserve(bytevec_t *v, size_t need)
+{
+    if (need <= v->cap)
+        return VLC_SUCCESS;
+
+    size_t ncap = v->cap ? v->cap : 1024;
+    while (ncap < need)
+    {
+        if (ncap > SIZE_MAX / 2)
+            return VLC_ENOMEM;
+        ncap *= 2;
+    }
+
+    uint8_t *np = realloc(v->p, ncap);
+    if (!np)
+        return VLC_ENOMEM;
+
+    v->p = np;
+    v->cap = ncap;
+    return VLC_SUCCESS;
+}
+
+static int bytevec_append(bytevec_t *v, const void *src, size_t n)
+{
+    if (n == 0)
+        return VLC_SUCCESS;
+    if (bytevec_reserve(v, v->len + n) != VLC_SUCCESS)
+        return VLC_ENOMEM;
+    memcpy(v->p + v->len, src, n);
+    v->len += n;
+    return VLC_SUCCESS;
+}
+
+static void bytevec_consume(bytevec_t *v, size_t n)
+{
+    if (n >= v->len)
+    {
+        v->len = 0;
+        return;
+    }
+
+    memmove(v->p, v->p + n, v->len - n);
+    v->len -= n;
+}
+
+static void bytevec_reset(bytevec_t *v)
+{
+    v->len = 0;
+}
+
+static void bytevec_clear(bytevec_t *v)
+{
+    free(v->p);
+    v->p = NULL;
+    v->len = 0;
+    v->cap = 0;
+}
+
+static int bitvec_reserve(bitvec_t *v, size_t need_bits)
+{
+    size_t need_bytes = (need_bits + 7) / 8;
+    if (need_bytes <= v->cap_bytes)
+        return VLC_SUCCESS;
+
+    size_t ncap = v->cap_bytes ? v->cap_bytes : 256;
+    while (ncap < need_bytes)
+    {
+        if (ncap > SIZE_MAX / 2)
+            return VLC_ENOMEM;
+        ncap *= 2;
+    }
+
+    uint8_t *np = realloc(v->p, ncap);
+    if (!np)
+        return VLC_ENOMEM;
+
+    if (ncap > v->cap_bytes)
+        memset(np + v->cap_bytes, 0, ncap - v->cap_bytes);
+
+    v->p = np;
+    v->cap_bytes = ncap;
+    return VLC_SUCCESS;
+}
+
+static int bitvec_append_bit(bitvec_t *v, uint8_t bit)
+{
+    if (bitvec_reserve(v, v->bit_len + 1) != VLC_SUCCESS)
+        return VLC_ENOMEM;
+
+    size_t byte = v->bit_len / 8;
+    int shift = 7 - (int)(v->bit_len % 8);
+    if ((v->bit_len % 8) == 0)
+        v->p[byte] = 0;
+    v->p[byte] |= (bit & 1u) << shift;
+    v->bit_len++;
+    return VLC_SUCCESS;
+}
+
+static int bitvec_append_bits(bitvec_t *v, uint32_t val, unsigned n)
+{
+    for (unsigned i = 0; i < n; ++i)
+    {
+        uint8_t b = (val >> (n - i - 1)) & 1u;
+        if (bitvec_append_bit(v, b) != VLC_SUCCESS)
+            return VLC_ENOMEM;
+    }
+    return VLC_SUCCESS;
+}
+
+static inline uint8_t bit_from_buf(const uint8_t *p, size_t bitpos)
+{
+    return (p[bitpos / 8] >> (7 - (bitpos % 8))) & 1u;
+}
+
+static int bitvec_append_range(bitvec_t *v, const uint8_t *src, size_t start, size_t end)
+{
+    for (size_t i = start; i < end; ++i)
+    {
+        if (bitvec_append_bit(v, bit_from_buf(src, i)) != VLC_SUCCESS)
+            return VLC_ENOMEM;
+    }
+    return VLC_SUCCESS;
+}
+
+static int bitvec_append_sce_as_cpe(bitvec_t *v, const uint8_t *src,
+                                    size_t sce_start, size_t sce_end)
+{
+    if (sce_end <= sce_start + 7)
+        return VLC_EGENERIC;
+
+    const size_t elem_start = sce_start + 7;
+
+    if (bitvec_append_bits(v, 0x1, 3) != VLC_SUCCESS)
+        return VLC_ENOMEM;
+    if (bitvec_append_range(v, src, sce_start + 3, sce_start + 7) != VLC_SUCCESS)
+        return VLC_ENOMEM;
+    if (bitvec_append_bit(v, 0) != VLC_SUCCESS)
+        return VLC_ENOMEM;
+    if (bitvec_append_range(v, src, elem_start, sce_end) != VLC_SUCCESS)
+        return VLC_ENOMEM;
+    if (bitvec_append_range(v, src, elem_start, sce_end) != VLC_SUCCESS)
+        return VLC_ENOMEM;
+
+    return VLC_SUCCESS;
+}
+
+static int bitvec_byte_align_zero(bitvec_t *v)
+{
+    while ((v->bit_len & 7u) != 0)
+        if (bitvec_append_bit(v, 0) != VLC_SUCCESS)
+            return VLC_ENOMEM;
+    return VLC_SUCCESS;
+}
+
+static void bitvec_clear(bitvec_t *v)
+{
+    free(v->p);
+    v->p = NULL;
+    v->bit_len = 0;
+    v->cap_bytes = 0;
+}
+
+static inline bool br_can_read(const bitreader_t *br, unsigned n)
+{
+    return br->pos + n <= br->bit_len;
+}
+
+static bool br_read(bitreader_t *br, unsigned n, uint32_t *v)
+{
+    if (!br_can_read(br, n))
+        return false;
+
+    uint32_t out = 0;
+    for (unsigned i = 0; i < n; ++i)
+    {
+        out = (out << 1) | bit_from_buf(br->p, br->pos);
+        br->pos++;
+    }
+    *v = out;
+    return true;
+}
+
+static bool br_read_bool(bitreader_t *br, bool *v)
+{
+    uint32_t b;
+    if (!br_read(br, 1, &b))
+        return false;
+    *v = b != 0;
+    return true;
+}
+
+static bool br_byte_align(bitreader_t *br)
+{
+    unsigned rem = (unsigned)((br->bit_len - br->pos) & 7u);
+    if (rem == 0)
+        return true;
+    uint32_t dummy;
+    return br_read(br, rem, &dummy);
+}
+
+static uint32_t psi_crc32(const uint8_t *data, size_t len)
+{
+    uint32_t crc = 0xffffffffu;
+    for (size_t i = 0; i < len; ++i)
+    {
+        crc ^= (uint32_t)data[i] << 24;
+        for (int b = 0; b < 8; ++b)
+        {
+            if (crc & 0x80000000u)
+                crc = (crc << 1) ^ 0x04c11db7u;
+            else
+                crc <<= 1;
+        }
+    }
+    return crc;
+}
+
+static bool parse_adts_header(const uint8_t *p, size_t len, adts_header_t *h)
+{
+    if (len < 7)
+        return false;
+    if (p[0] != 0xff || (p[1] & 0xf0) != 0xf0)
+        return false;
+
+    h->mpeg_id = (p[1] >> 3) & 0x1;
+    h->layer = (p[1] >> 1) & 0x3;
+    h->protection_absent = (p[1] & 0x1) != 0;
+    h->profile = (p[2] >> 6) & 0x3;
+    h->sf_index = (p[2] >> 2) & 0xf;
+    h->private_bit = (p[2] >> 1) & 0x1;
+    h->channel_configuration = ((p[2] & 0x1) << 2) | ((p[3] >> 6) & 0x3);
+    h->originality = (p[3] >> 5) & 0x1;
+    h->home = (p[3] >> 4) & 0x1;
+    h->copyrighted = (p[3] >> 3) & 0x1;
+    h->copyright_id_start = (p[3] >> 2) & 0x1;
+    h->frame_length = ((p[3] & 0x3) << 11) | (p[4] << 3) | ((p[5] >> 5) & 0x7);
+    h->buffer_fullness = ((p[5] & 0x1f) << 6) | ((p[6] >> 2) & 0x3f);
+    h->num_raw_data_blocks = p[6] & 0x3;
+
+    if (h->layer != 0)
+        return false;
+
+    return h->frame_length >= 7;
+}
+
+static void write_adts_header(uint8_t out[7], const adts_header_t *h,
+                              uint8_t ch_cfg, uint16_t frame_length)
+{
+    out[0] = 0xff;
+    out[1] = 0xf0 | ((h->mpeg_id & 0x1) << 3) | ((h->layer & 0x3) << 1) | 0x1;
+    out[2] = ((h->profile & 0x3) << 6) | ((h->sf_index & 0xf) << 2)
+           | ((h->private_bit & 0x1) << 1) | ((ch_cfg >> 2) & 0x1);
+    out[3] = ((ch_cfg & 0x3) << 6) | ((h->originality & 0x1) << 5)
+           | ((h->home & 0x1) << 4) | ((h->copyrighted & 0x1) << 3)
+           | ((h->copyright_id_start & 0x1) << 2) | ((frame_length >> 11) & 0x3);
+    out[4] = (frame_length >> 3) & 0xff;
+    out[5] = ((frame_length & 0x7) << 5) | ((h->buffer_fullness >> 6) & 0x1f);
+    out[6] = ((h->buffer_fullness & 0x3f) << 2);
+}
+
+static int huffman_decode(bitreader_t *br, const huff_entry_t *table,
+                          size_t table_size, uint32_t *index)
+{
+    uint32_t code = 0;
+
+    for (unsigned len = 1; len <= 19; ++len)
+    {
+        uint32_t b;
+        if (!br_read(br, 1, &b))
+            return VLC_EGENERIC;
+        code = (code << 1) | b;
+
+        for (size_t i = 0; i < table_size; ++i)
+        {
+            if (table[i].len == len && table[i].code == code)
+            {
+                *index = (uint32_t)i;
+                return VLC_SUCCESS;
+            }
+        }
+    }
+
+    return VLC_EGENERIC;
+}
+
+#define ONLY_LONG_SEQUENCE 0
+#define LONG_START_SEQUENCE 1
+#define EIGHT_SHORT_SEQUENCE 2
+#define LONG_STOP_SEQUENCE 3
+
+static const int swb_offset_long_window_48khz[] = {
+  0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 48, 56, 64, 72, 80, 88, 96, 108,
+  120, 132, 144, 160, 176, 196, 216, 240, 264, 292, 320, 352, 384, 416, 448,
+  480, 512, 544, 576, 608, 640, 672, 704, 736, 768, 800, 832, 864, 896, 928,
+  1024
+};
+static const int swb_offset_short_window_48khz[] = {
+  0, 4, 8, 12, 16, 20, 28, 36, 44, 56, 68, 80, 96, 112, 128
+};
+
+static int parse_ics_info(bitreader_t *br, ics_parse_t *ics)
+{
+    const int PRED_SFB_MAX = 40;
+    uint32_t v;
+    bool b;
+
+    if (!br_read(br, 1, &v))
+        return VLC_EGENERIC;
+    if (!br_read(br, 2, &v))
+        return VLC_EGENERIC;
+    ics->window_sequence = (int)v;
+    if (!br_read(br, 1, &v))
+        return VLC_EGENERIC;
+
+    if (ics->window_sequence == EIGHT_SHORT_SEQUENCE)
+    {
+        if (!br_read(br, 4, &v))
+            return VLC_EGENERIC;
+        ics->max_sfb = (int)v;
+        if (!br_read(br, 7, &v))
+            return VLC_EGENERIC;
+
+        ics->num_window_groups = 1;
+        ics->window_group_length[0] = 1;
+        for (int i = 0; i < 7; ++i)
+        {
+            if ((v & (1u << (6 - i))) == 0)
+            {
+                if (ics->num_window_groups >= DM_MAX_WINDOW_GROUPS)
+                    return VLC_EGENERIC;
+                ics->window_group_length[ics->num_window_groups++] = 1;
+            }
+            else
+            {
+                ics->window_group_length[ics->num_window_groups - 1]++;
+            }
+        }
+    }
+    else
+    {
+        if (!br_read(br, 6, &v))
+            return VLC_EGENERIC;
+        ics->max_sfb = (int)v;
+        if (!br_read_bool(br, &b))
+            return VLC_EGENERIC;
+        if (b)
+        {
+            if (!br_read_bool(br, &b))
+                return VLC_EGENERIC;
+            if (b && !br_read(br, 5, &v))
+                return VLC_EGENERIC;
+            for (int sfb = 0; sfb < __MIN(ics->max_sfb, PRED_SFB_MAX); ++sfb)
+                if (!br_read_bool(br, &b))
+                    return VLC_EGENERIC;
+        }
+
+        ics->num_window_groups = 1;
+        ics->window_group_length[0] = 1;
+    }
+
+    if (ics->max_sfb < 0 || ics->max_sfb > DM_MAX_SFB)
+        return VLC_EGENERIC;
+
+    if (ics->window_sequence == EIGHT_SHORT_SEQUENCE)
+    {
+        for (int g = 0; g < ics->num_window_groups; ++g)
+        {
+            int off = 0;
+            for (int i = 0; i < ics->max_sfb; ++i)
+            {
+                int width = (swb_offset_short_window_48khz[i + 1] -
+                             swb_offset_short_window_48khz[i]) *
+                             ics->window_group_length[g];
+                ics->sect_sfb_offset[g][i] = off;
+                off += width;
+            }
+            ics->sect_sfb_offset[g][ics->max_sfb] = off;
+        }
+    }
+    else
+    {
+        for (int i = 0; i <= ics->max_sfb; ++i)
+            ics->sect_sfb_offset[0][i] = swb_offset_long_window_48khz[i];
+    }
+
+    return VLC_SUCCESS;
+}
+
+static int parse_section_data(bitreader_t *br, ics_parse_t *ics)
+{
+    const int sec_bits = (ics->window_sequence == EIGHT_SHORT_SEQUENCE) ? 3 : 5;
+    const int sec_esc = (1 << sec_bits) - 1;
+
+    for (int g = 0; g < ics->num_window_groups; ++g)
+    {
+        int k = 0;
+        int i = 0;
+
+        while (k < ics->max_sfb)
+        {
+            uint32_t cb;
+            if (!br_read(br, 4, &cb))
+                return VLC_EGENERIC;
+            ics->sect_cb[g][i] = (int)cb;
+
+            int sect_len = 0;
+            for (;;)
+            {
+                uint32_t inc;
+                if (!br_read(br, sec_bits, &inc))
+                    return VLC_EGENERIC;
+                sect_len += (int)inc;
+                if ((int)inc != sec_esc)
+                    break;
+            }
+
+            if (sect_len <= 0 || k + sect_len > ics->max_sfb)
+                return VLC_EGENERIC;
+
+            ics->sect_start[g][i] = k;
+            ics->sect_end[g][i] = k + sect_len;
+            for (int sfb = k; sfb < k + sect_len; ++sfb)
+                ics->sfb_cb[g][sfb] = (int)cb;
+
+            k += sect_len;
+            i++;
+            if (i >= DM_MAX_SECT)
+                return VLC_EGENERIC;
+        }
+
+        ics->num_sect[g] = i;
+    }
+
+    return VLC_SUCCESS;
+}
+
+static int parse_scale_factor_data(bitreader_t *br, const ics_parse_t *ics)
+{
+    for (int g = 0; g < ics->num_window_groups; ++g)
+    {
+        for (int sfb = 0; sfb < ics->max_sfb; ++sfb)
+        {
+            if (ics->sfb_cb[g][sfb] == 0)
+                continue;
+            uint32_t idx;
+            if (huffman_decode(br, scalefactor_table, SCALEFACTOR_TABLE_SIZE, &idx) != VLC_SUCCESS)
+                return VLC_EGENERIC;
+            (void)idx;
+        }
+    }
+    return VLC_SUCCESS;
+}
+
+static int parse_pulse_data(bitreader_t *br)
+{
+    uint32_t num, v;
+    if (!br_read(br, 2, &num))
+        return VLC_EGENERIC;
+    if (!br_read(br, 6, &v))
+        return VLC_EGENERIC;
+    for (uint32_t i = 0; i <= num; ++i)
+    {
+        if (!br_read(br, 5, &v) || !br_read(br, 4, &v))
+            return VLC_EGENERIC;
+    }
+    return VLC_SUCCESS;
+}
+
+static int parse_tns_data(bitreader_t *br, int window_sequence)
+{
+    const int num_windows = window_sequence == EIGHT_SHORT_SEQUENCE ? 8 : 1;
+    const int n_filt_bits = window_sequence == EIGHT_SHORT_SEQUENCE ? 1 : 2;
+    const int length_bits = window_sequence == EIGHT_SHORT_SEQUENCE ? 4 : 6;
+    const int order_bits = window_sequence == EIGHT_SHORT_SEQUENCE ? 3 : 5;
+
+    uint32_t v;
+    bool b;
+
+    for (int w = 0; w < num_windows; ++w)
+    {
+        if (!br_read(br, n_filt_bits, &v))
+            return VLC_EGENERIC;
+        int n_filt = (int)v;
+        int coef_bits = 3;
+
+        if (n_filt)
+        {
+            if (!br_read(br, 1, &v))
+                return VLC_EGENERIC;
+            if (v)
+                coef_bits = 4;
+        }
+
+        for (int filt = 0; filt < n_filt; ++filt)
+        {
+            if (!br_read(br, length_bits, &v))
+                return VLC_EGENERIC;
+            if (!br_read(br, order_bits, &v))
+                return VLC_EGENERIC;
+            int order = (int)v;
+            if (order)
+            {
+                if (!br_read(br, 1, &v) || !br_read_bool(br, &b))
+                    return VLC_EGENERIC;
+                int nbits = coef_bits - (b ? 1 : 0);
+                for (int i = 0; i < order; ++i)
+                    if (!br_read(br, nbits, &v))
+                        return VLC_EGENERIC;
+            }
+        }
+    }
+
+    return VLC_SUCCESS;
+}
+
+static int parse_gain_control_data(bitreader_t *br, int window_sequence)
+{
+    uint32_t max_band, v;
+    if (!br_read(br, 2, &max_band))
+        return VLC_EGENERIC;
+
+    int wd_max = 0;
+    for (uint32_t bd = 0; bd <= max_band; ++bd)
+    {
+        if (window_sequence == ONLY_LONG_SEQUENCE)
+            wd_max = 1;
+        else if (window_sequence == LONG_START_SEQUENCE)
+            wd_max = 2;
+        else if (window_sequence == EIGHT_SHORT_SEQUENCE)
+            wd_max = 8;
+        else
+            wd_max = 2;
+
+        for (int wd = 0; wd < wd_max; ++wd)
+        {
+            if (!br_read(br, 3, &v))
+                return VLC_EGENERIC;
+            int adjust_num = (int)v;
+            for (int ad = 0; ad < adjust_num; ++ad)
+            {
+                if (!br_read(br, 4, &v))
+                    return VLC_EGENERIC;
+                if (window_sequence == ONLY_LONG_SEQUENCE)
+                {
+                    if (!br_read(br, 4, &v))
+                        return VLC_EGENERIC;
+                }
+                else if (window_sequence == LONG_START_SEQUENCE)
+                {
+                    if (!br_read(br, (wd == 0) ? 4 : 2, &v))
+                        return VLC_EGENERIC;
+                }
+                else if (window_sequence == EIGHT_SHORT_SEQUENCE)
+                {
+                    if (!br_read(br, 2, &v))
+                        return VLC_EGENERIC;
+                }
+                else
+                {
+                    if (!br_read(br, (wd == 0) ? 4 : 5, &v))
+                        return VLC_EGENERIC;
+                }
+            }
+        }
+    }
+
+    return VLC_SUCCESS;
+}
+
+static void quad_from_index(bool signed_values, int lav, int index,
+                            int *w, int *x, int *y, int *z)
+{
+    int off = signed_values ? lav : 0;
+    int mod = signed_values ? (2 * lav + 1) : (lav + 1);
+    *w = (index / (mod * mod * mod)) - off;
+    index -= (*w + off) * mod * mod * mod;
+    *x = (index / (mod * mod)) - off;
+    index -= (*x + off) * mod * mod;
+    *y = (index / mod) - off;
+    index -= (*y + off) * mod;
+    *z = index - off;
+}
+
+static void pair_from_index(bool signed_values, int lav, int index,
+                            int *y, int *z)
+{
+    int off = signed_values ? lav : 0;
+    int mod = signed_values ? (2 * lav + 1) : (lav + 1);
+    *y = (index / mod) - off;
+    index -= (*y + off) * mod;
+    *z = index - off;
+}
+
+static int parse_escape(bitreader_t *br)
+{
+    uint32_t b, esc;
+    int count = 0;
+    for (;;)
+    {
+        if (!br_read(br, 1, &b))
+            return VLC_EGENERIC;
+        if (!b)
+            break;
+        count++;
+    }
+    if (!br_read(br, count + 4, &esc))
+        return VLC_EGENERIC;
+    (void)esc;
+    return VLC_SUCCESS;
+}
+
+static int parse_spectral_data(bitreader_t *br, const ics_parse_t *ics)
+{
+    for (int g = 0; g < ics->num_window_groups; ++g)
+    {
+        for (int i = 0; i < ics->num_sect[g]; ++i)
+        {
+            int cb = ics->sect_cb[g][i];
+            if (cb == 0 || cb > 11)
+                continue;
+
+            for (int k = ics->sect_sfb_offset[g][ics->sect_start[g][i]];
+                 k < ics->sect_sfb_offset[g][ics->sect_end[g][i]]; )
+            {
+                uint32_t idx;
+                if (cb < 5)
+                {
+                    const huff_entry_t *table;
+                    size_t size;
+                    switch (cb)
+                    {
+                        case 1: table = spectrum1_table; size = SPECTRUM1_TABLE_SIZE; break;
+                        case 2: table = spectrum2_table; size = SPECTRUM2_TABLE_SIZE; break;
+                        case 3: table = spectrum3_table; size = SPECTRUM3_TABLE_SIZE; break;
+                        default: table = spectrum4_table; size = SPECTRUM4_TABLE_SIZE; break;
+                    }
+                    if (huffman_decode(br, table, size, &idx) != VLC_SUCCESS)
+                        return VLC_EGENERIC;
+
+                    bool signed_values = (cb == 1 || cb == 2);
+                    int lav = signed_values ? 1 : 2;
+                    int w, x, y, z;
+                    quad_from_index(signed_values, lav, (int)idx, &w, &x, &y, &z);
+
+                    if (!signed_values)
+                    {
+                        uint32_t b;
+                        if (w != 0 && !br_read(br, 1, &b)) return VLC_EGENERIC;
+                        if (x != 0 && !br_read(br, 1, &b)) return VLC_EGENERIC;
+                        if (y != 0 && !br_read(br, 1, &b)) return VLC_EGENERIC;
+                        if (z != 0 && !br_read(br, 1, &b)) return VLC_EGENERIC;
+                    }
+
+                    k += 4;
+                }
+                else
+                {
+                    const huff_entry_t *table;
+                    size_t size;
+                    bool signed_values = false;
+                    int lav;
+
+                    switch (cb)
+                    {
+                        case 5: table = spectrum5_table; size = SPECTRUM5_TABLE_SIZE; signed_values = true; lav = 4; break;
+                        case 6: table = spectrum6_table; size = SPECTRUM6_TABLE_SIZE; signed_values = true; lav = 4; break;
+                        case 7: table = spectrum7_table; size = SPECTRUM7_TABLE_SIZE; lav = 7; break;
+                        case 8: table = spectrum8_table; size = SPECTRUM8_TABLE_SIZE; lav = 7; break;
+                        case 9: table = spectrum9_table; size = SPECTRUM9_TABLE_SIZE; lav = 12; break;
+                        case 10: table = spectrum10_table; size = SPECTRUM10_TABLE_SIZE; lav = 12; break;
+                        default: table = spectrum11_table; size = SPECTRUM11_TABLE_SIZE; lav = 16; break;
+                    }
+
+                    if (huffman_decode(br, table, size, &idx) != VLC_SUCCESS)
+                        return VLC_EGENERIC;
+
+                    int y, z;
+                    pair_from_index(signed_values, lav, (int)idx, &y, &z);
+
+                    if (!signed_values)
+                    {
+                        uint32_t b;
+                        if (y != 0 && !br_read(br, 1, &b)) return VLC_EGENERIC;
+                        if (z != 0 && !br_read(br, 1, &b)) return VLC_EGENERIC;
+                    }
+
+                    if (cb == 11)
+                    {
+                        if (abs(y) == 16 && parse_escape(br) != VLC_SUCCESS)
+                            return VLC_EGENERIC;
+                        if (abs(z) == 16 && parse_escape(br) != VLC_SUCCESS)
+                            return VLC_EGENERIC;
+                    }
+
+                    k += 2;
+                }
+            }
+        }
+    }
+
+    return VLC_SUCCESS;
+}
+
+static int parse_individual_channel_stream(bitreader_t *br, bool common_window)
+{
+    uint32_t v;
+    bool b;
+
+    if (!br_read(br, 8, &v))
+        return VLC_EGENERIC;
+    if (common_window)
+        return VLC_EGENERIC;
+
+    ics_parse_t ics;
+    memset(&ics, 0, sizeof(ics));
+
+    if (parse_ics_info(br, &ics) != VLC_SUCCESS)
+        return VLC_EGENERIC;
+    if (parse_section_data(br, &ics) != VLC_SUCCESS)
+        return VLC_EGENERIC;
+    if (parse_scale_factor_data(br, &ics) != VLC_SUCCESS)
+        return VLC_EGENERIC;
+
+    if (!br_read_bool(br, &b))
+        return VLC_EGENERIC;
+    if (b && parse_pulse_data(br) != VLC_SUCCESS)
+        return VLC_EGENERIC;
+
+    if (!br_read_bool(br, &b))
+        return VLC_EGENERIC;
+    if (b && parse_tns_data(br, ics.window_sequence) != VLC_SUCCESS)
+        return VLC_EGENERIC;
+
+    if (!br_read_bool(br, &b))
+        return VLC_EGENERIC;
+    if (b && parse_gain_control_data(br, ics.window_sequence) != VLC_SUCCESS)
+        return VLC_EGENERIC;
+
+    if (parse_spectral_data(br, &ics) != VLC_SUCCESS)
+        return VLC_EGENERIC;
+
+    return VLC_SUCCESS;
+}
+
+static int parse_single_channel_element(bitreader_t *br)
+{
+    uint32_t v;
+    if (!br_read(br, 4, &v))
+        return VLC_EGENERIC;
+    if (parse_individual_channel_stream(br, false) != VLC_SUCCESS)
+        return VLC_EGENERIC;
+    return VLC_SUCCESS;
+}
+
+static int parse_program_config_element(bitreader_t *br)
+{
+    uint32_t v;
+    bool b;
+
+    if (!br_read(br, 4, &v) || !br_read(br, 2, &v) || !br_read(br, 4, &v))
+        return VLC_EGENERIC;
+
+    uint32_t num_front, num_side, num_back, num_lfe, num_assoc, num_cc;
+    if (!br_read(br, 4, &num_front) || !br_read(br, 4, &num_side) ||
+        !br_read(br, 4, &num_back) || !br_read(br, 2, &num_lfe) ||
+        !br_read(br, 3, &num_assoc) || !br_read(br, 4, &num_cc))
+        return VLC_EGENERIC;
+
+    if (!br_read_bool(br, &b))
+        return VLC_EGENERIC;
+    if (b && !br_read(br, 4, &v))
+        return VLC_EGENERIC;
+
+    if (!br_read_bool(br, &b))
+        return VLC_EGENERIC;
+    if (b && !br_read(br, 4, &v))
+        return VLC_EGENERIC;
+
+    if (!br_read_bool(br, &b))
+        return VLC_EGENERIC;
+    if (b && (!br_read(br, 2, &v) || !br_read_bool(br, &b)))
+        return VLC_EGENERIC;
+
+    for (uint32_t i = 0; i < num_front; ++i)
+        if (!br_read(br, 1, &v) || !br_read(br, 4, &v))
+            return VLC_EGENERIC;
+    for (uint32_t i = 0; i < num_side; ++i)
+        if (!br_read(br, 1, &v) || !br_read(br, 4, &v))
+            return VLC_EGENERIC;
+    for (uint32_t i = 0; i < num_back; ++i)
+        if (!br_read(br, 1, &v) || !br_read(br, 4, &v))
+            return VLC_EGENERIC;
+    for (uint32_t i = 0; i < num_lfe; ++i)
+        if (!br_read(br, 4, &v))
+            return VLC_EGENERIC;
+    for (uint32_t i = 0; i < num_assoc; ++i)
+        if (!br_read(br, 4, &v))
+            return VLC_EGENERIC;
+    for (uint32_t i = 0; i < num_cc; ++i)
+        if (!br_read(br, 1, &v) || !br_read(br, 4, &v))
+            return VLC_EGENERIC;
+
+    if (!br_byte_align(br))
+        return VLC_EGENERIC;
+
+    uint32_t comment_bytes;
+    if (!br_read(br, 8, &comment_bytes))
+        return VLC_EGENERIC;
+    for (uint32_t i = 0; i < comment_bytes; ++i)
+        if (!br_read(br, 8, &v))
+            return VLC_EGENERIC;
+
+    return VLC_SUCCESS;
+}
+
+static int parse_extension_payload(bitreader_t *br, int cnt)
+{
+    uint32_t ext_type, v;
+    if (!br_read(br, 4, &ext_type))
+        return VLC_EGENERIC;
+
+    if (ext_type == 0x1)
+    {
+        if (!br_read(br, 4, &v))
+            return VLC_EGENERIC;
+        for (int i = 0; i < cnt - 1; ++i)
+            if (!br_read(br, 8, &v))
+                return VLC_EGENERIC;
+        return cnt;
+    }
+
+    int bits = 8 * (cnt - 1) + 4;
+    for (int i = 0; i < bits; ++i)
+        if (!br_read(br, 1, &v))
+            return VLC_EGENERIC;
+
+    return cnt;
+}
+
+static int parse_fill_element(bitreader_t *br)
+{
+    uint32_t cnt, v;
+    if (!br_read(br, 4, &cnt))
+        return VLC_EGENERIC;
+    if (cnt == 15)
+    {
+        if (!br_read(br, 8, &v))
+            return VLC_EGENERIC;
+        cnt += v - 1;
+    }
+
+    while ((int)cnt > 0)
+    {
+        int consumed = parse_extension_payload(br, (int)cnt);
+        if (consumed <= 0)
+            return VLC_EGENERIC;
+        cnt -= consumed;
+    }
+
+    return VLC_SUCCESS;
+}
+
+typedef struct
+{
+    bool ok;
+    bool have_end;
+    size_t sce_start[2];
+    size_t sce_end[2];
+    int sce_count;
+    size_t end_start;
+    size_t end_end;
+} aac_split_points_t;
+
+static aac_split_points_t parse_aac_raw_data_block(const uint8_t *raw, size_t raw_len)
+{
+    aac_split_points_t out;
+    memset(&out, 0, sizeof(out));
+
+    bitreader_t br = {
+        .p = raw,
+        .bit_len = raw_len * 8,
+        .pos = 0,
+    };
+
+    while (br.pos + 3 <= br.bit_len)
+    {
+        size_t elem_start = br.pos;
+        uint32_t id;
+        if (!br_read(&br, 3, &id))
+            break;
+
+        if (id == 0x0)
+        {
+            if (parse_single_channel_element(&br) != VLC_SUCCESS)
+                return out;
+
+            if (out.sce_count < 2)
+            {
+                out.sce_start[out.sce_count] = elem_start;
+                out.sce_end[out.sce_count] = br.pos;
+            }
+            out.sce_count++;
+        }
+        else if (id == 0x5)
+        {
+            if (parse_program_config_element(&br) != VLC_SUCCESS)
+                return out;
+        }
+        else if (id == 0x6)
+        {
+            if (parse_fill_element(&br) != VLC_SUCCESS)
+                return out;
+        }
+        else if (id == 0x7)
+        {
+            out.end_start = elem_start;
+            out.end_end = br.pos;
+            out.have_end = true;
+            out.ok = true;
+            return out;
+        }
+        else
+        {
+            return out;
+        }
+    }
+
+    return out;
+}
+
+static int build_stereo_frame_from_sce(const adts_header_t *h, const uint8_t *raw,
+                                       aac_split_points_t *sp, int sce_index,
+                                       bytevec_t *dst)
+{
+    if (sce_index >= sp->sce_count)
+        return VLC_EGENERIC;
+
+    bitvec_t bits = {0};
+    int ret = VLC_SUCCESS;
+
+    if (bitvec_append_sce_as_cpe(&bits, raw, sp->sce_start[sce_index], sp->sce_end[sce_index]) != VLC_SUCCESS)
+    {
+        ret = VLC_ENOMEM;
+        goto out;
+    }
+    if (sp->have_end)
+    {
+        if (bitvec_append_range(&bits, raw, sp->end_start, sp->end_end) != VLC_SUCCESS)
+        {
+            ret = VLC_ENOMEM;
+            goto out;
+        }
+    }
+    if (bitvec_byte_align_zero(&bits) != VLC_SUCCESS)
+    {
+        ret = VLC_ENOMEM;
+        goto out;
+    }
+
+    size_t payload_len = bits.bit_len / 8;
+    if (payload_len + 7 > UINT16_MAX)
+    {
+        ret = VLC_EGENERIC;
+        goto out;
+    }
+
+    uint8_t adts[7];
+    write_adts_header(adts, h, 2, (uint16_t)(payload_len + 7));
+
+    if (bytevec_append(dst, adts, sizeof(adts)) != VLC_SUCCESS ||
+        bytevec_append(dst, bits.p, payload_len) != VLC_SUCCESS)
+    {
+        ret = VLC_ENOMEM;
+        goto out;
+    }
+
+out:
+    bitvec_clear(&bits);
+    return ret;
+}
+
+static int transform_adts_payload(const uint8_t *in, size_t in_len,
+                                  bytevec_t *main_out, bytevec_t *sub_out)
+{
+    size_t off = 0;
+    bool any_sub = false;
+
+    while (off + 7 <= in_len)
+    {
+        adts_header_t h;
+        if (!parse_adts_header(in + off, in_len - off, &h))
+            break;
+        if (h.frame_length < 7 || off + h.frame_length > in_len)
+            break;
+
+        const uint8_t *frame = in + off;
+        size_t frame_len = h.frame_length;
+
+        if (h.channel_configuration != 0)
+        {
+            if (bytevec_append(main_out, frame, frame_len) != VLC_SUCCESS)
+                return VLC_ENOMEM;
+            off += frame_len;
+            continue;
+        }
+
+        size_t raw_start = (h.protection_absent ? 7 : 9) + 2 * h.num_raw_data_blocks;
+        if (raw_start >= frame_len)
+        {
+            if (bytevec_append(main_out, frame, frame_len) != VLC_SUCCESS)
+                return VLC_ENOMEM;
+            off += frame_len;
+            continue;
+        }
+
+        const uint8_t *raw = frame + raw_start;
+        size_t raw_len = frame_len - raw_start;
+
+        aac_split_points_t sp = parse_aac_raw_data_block(raw, raw_len);
+        if (!sp.ok || !sp.have_end || sp.sce_count < 2)
+        {
+            if (bytevec_append(main_out, frame, frame_len) != VLC_SUCCESS)
+                return VLC_ENOMEM;
+            off += frame_len;
+            continue;
+        }
+
+        if (build_stereo_frame_from_sce(&h, raw, &sp, 0, main_out) != VLC_SUCCESS)
+            return VLC_EGENERIC;
+
+        if (h.channel_configuration == 0 && sp.sce_count >= 2)
+        {
+            if (build_stereo_frame_from_sce(&h, raw, &sp, 1, sub_out) != VLC_SUCCESS)
+                return VLC_EGENERIC;
+            any_sub = true;
+        }
+
+        off += frame_len;
+    }
+
+    if (off < in_len)
+    {
+        if (bytevec_append(main_out, in + off, in_len - off) != VLC_SUCCESS)
+            return VLC_ENOMEM;
+    }
+
+    if (!any_sub)
+        sub_out->len = 0;
+
+    return VLC_SUCCESS;
+}
+
+static int emit_ts_packet(bytevec_t *out, uint16_t pid, bool pusi, uint8_t *cc,
+                          const uint8_t *payload, size_t payload_len)
+{
+    if (payload_len > 184)
+        return VLC_EGENERIC;
+
+    uint8_t pkt[TS_PACKET_SIZE];
+    memset(pkt, 0xff, sizeof(pkt));
+
+    pkt[0] = TS_SYNC_BYTE;
+    pkt[1] = ((pusi ? 1u : 0u) << 6) | ((pid >> 8) & 0x1f);
+    pkt[2] = pid & 0xff;
+
+    size_t pos = 4;
+    if (payload_len == 184)
+    {
+        pkt[3] = 0x10 | (*cc & 0x0f);
+    }
+    else
+    {
+        pkt[3] = 0x30 | (*cc & 0x0f);
+        uint8_t af_len = (uint8_t)(183 - payload_len);
+        pkt[pos++] = af_len;
+        if (af_len > 0)
+        {
+            pkt[pos++] = 0x00;
+            if (af_len > 1)
+                memset(pkt + pos, 0xff, af_len - 1);
+            pos += af_len - 1;
+        }
+    }
+
+    if (payload_len > 0)
+        memcpy(pkt + pos, payload, payload_len);
+
+    if (bytevec_append(out, pkt, sizeof(pkt)) != VLC_SUCCESS)
+        return VLC_ENOMEM;
+
+    *cc = (*cc + 1) & 0x0f;
+    return VLC_SUCCESS;
+}
+
+static int emit_psi_section(bytevec_t *out, uint16_t pid, uint8_t *cc,
+                            const uint8_t *section, size_t section_len)
+{
+    size_t off = 0;
+    bool first = true;
+
+    while (off < section_len)
+    {
+        uint8_t payload[184];
+        size_t plen = 0;
+
+        if (first)
+            payload[plen++] = 0x00;
+
+        size_t cap = 184 - plen;
+        size_t n = __MIN(cap, section_len - off);
+        memcpy(payload + plen, section + off, n);
+        plen += n;
+
+        if (emit_ts_packet(out, pid, first, cc, payload, plen) != VLC_SUCCESS)
+            return VLC_ENOMEM;
+
+        off += n;
+        first = false;
+    }
+
+    return VLC_SUCCESS;
+}
+
+static int emit_pes_packets(bytevec_t *out, uint16_t pid, uint8_t *cc,
+                            const uint8_t *pes, size_t pes_len)
+{
+    size_t off = 0;
+    bool first = true;
+
+    while (off < pes_len)
+    {
+        size_t n = __MIN((size_t)184, pes_len - off);
+        if (emit_ts_packet(out, pid, first, cc, pes + off, n) != VLC_SUCCESS)
+            return VLC_ENOMEM;
+        off += n;
+        first = false;
+    }
+
+    if (pes_len == 0)
+    {
+        if (emit_ts_packet(out, pid, true, cc, NULL, 0) != VLC_SUCCESS)
+            return VLC_ENOMEM;
+    }
+
+    return VLC_SUCCESS;
+}
+
+static bool parse_pat_find_pmt(const uint8_t *section, size_t sec_len, int *pmt_pid)
+{
+    if (sec_len < 12)
+        return false;
+    if (section[0] != 0x00)
+        return false;
+
+    size_t end = sec_len - 4;
+    for (size_t i = 8; i + 4 <= end; i += 4)
+    {
+        uint16_t program = (section[i] << 8) | section[i + 1];
+        uint16_t pid = ((section[i + 2] & 0x1f) << 8) | section[i + 3];
+        if (program != 0)
+        {
+            *pmt_pid = pid;
+            return true;
+        }
+    }
+
+    return false;
+}
+
+static int rebuild_pmt_section(stream_t *s, stream_sys_t *sys,
+                               const uint8_t *orig, size_t orig_len,
+                               bytevec_t *new_sec)
+{
+    if (orig_len < 12 || orig[0] != 0x02)
+        return VLC_EGENERIC;
+
+    uint16_t section_length = ((orig[1] & 0x0f) << 8) | orig[2];
+    if (section_length + 3 != orig_len)
+        return VLC_EGENERIC;
+
+    uint16_t program_info_length = ((orig[10] & 0x0f) << 8) | orig[11];
+    size_t es_start = 12 + program_info_length;
+    if (es_start > orig_len - 4)
+        return VLC_EGENERIC;
+
+    bytevec_reset(new_sec);
+    if (bytevec_append(new_sec, orig, es_start) != VLC_SUCCESS)
+        return VLC_ENOMEM;
+
+    sys->aac_pid1 = -1;
+    sys->aac_pid2 = -1;
+
+    size_t i = es_start;
+    while (i + 5 <= orig_len - 4)
+    {
+        uint8_t stream_type = orig[i];
+        uint16_t pid = ((orig[i + 1] & 0x1f) << 8) | orig[i + 2];
+        uint16_t es_info_length = ((orig[i + 3] & 0x0f) << 8) | orig[i + 4];
+        size_t es_size = 5 + es_info_length;
+
+        if (i + es_size > orig_len - 4)
+            return VLC_EGENERIC;
+
+        uint8_t entry[5];
+        entry[0] = stream_type;
+
+        uint16_t out_pid = pid;
+        if (stream_type == DM_AAC_STREAM_TYPE)
+        {
+            if (sys->aac_pid1 < 0)
+            {
+                sys->aac_pid1 = pid;
+                if (sys->dualmono_detected)
+                    out_pid = sys->mapped_pid1;
+            }
+            else if (sys->aac_pid2 < 0)
+            {
+                sys->aac_pid2 = pid;
+                if (sys->dualmono_detected)
+                    out_pid = sys->mapped_pid2;
+            }
+        }
+
+        entry[1] = 0xe0 | ((out_pid >> 8) & 0x1f);
+        entry[2] = out_pid & 0xff;
+        entry[3] = 0xf0 | ((es_info_length >> 8) & 0x0f);
+        entry[4] = es_info_length & 0xff;
+
+        if (bytevec_append(new_sec, entry, sizeof(entry)) != VLC_SUCCESS ||
+            bytevec_append(new_sec, orig + i + 5, es_info_length) != VLC_SUCCESS)
+            return VLC_ENOMEM;
+
+        i += es_size;
+    }
+
+    if (sys->dualmono_detected && sys->aac_pid1 < 0)
+    {
+        uint8_t add[5] = {
+            DM_AAC_STREAM_TYPE,
+            (uint8_t)(0xe0 | ((sys->mapped_pid1 >> 8) & 0x1f)),
+            (uint8_t)(sys->mapped_pid1 & 0xff),
+            0xf0, 0x00,
+        };
+        if (bytevec_append(new_sec, add, sizeof(add)) != VLC_SUCCESS)
+            return VLC_ENOMEM;
+    }
+
+    if (sys->dualmono_detected && sys->aac_pid2 < 0)
+    {
+        uint8_t add[5] = {
+            DM_AAC_STREAM_TYPE,
+            (uint8_t)(0xe0 | ((sys->mapped_pid2 >> 8) & 0x1f)),
+            (uint8_t)(sys->mapped_pid2 & 0xff),
+            0xf0, 0x00,
+        };
+        if (bytevec_append(new_sec, add, sizeof(add)) != VLC_SUCCESS)
+            return VLC_ENOMEM;
+    }
+
+    size_t with_crc = new_sec->len + 4;
+    if (with_crc < 3 || with_crc > 1024)
+        return VLC_EGENERIC;
+
+    uint16_t new_sec_len = (uint16_t)(with_crc - 3);
+    new_sec->p[1] = (new_sec->p[1] & 0xf0) | ((new_sec_len >> 8) & 0x0f);
+    new_sec->p[2] = new_sec_len & 0xff;
+
+    uint32_t crc = psi_crc32(new_sec->p, new_sec->len);
+    uint8_t crc_bytes[4] = {
+        (uint8_t)(crc >> 24),
+        (uint8_t)(crc >> 16),
+        (uint8_t)(crc >> 8),
+        (uint8_t)crc,
+    };
+
+    if (bytevec_append(new_sec, crc_bytes, sizeof(crc_bytes)) != VLC_SUCCESS)
+        return VLC_ENOMEM;
+
+    if (sys->dualmono_detected)
+    {
+        msg_Dbg(s, "PMT updated: source AAC PID1=%d PID2=%d -> mapped PID1=%u PID2=%u",
+                sys->aac_pid1, sys->aac_pid2, sys->mapped_pid1, sys->mapped_pid2);
+    }
+
+    return VLC_SUCCESS;
+}
+
+static int rewrite_pes_payload(const uint8_t *pes, size_t pes_len,
+                               bytevec_t *main_pes, bytevec_t *sub_pes)
+{
+    bytevec_reset(main_pes);
+    bytevec_reset(sub_pes);
+
+    if (pes_len < 9 || pes[0] != 0x00 || pes[1] != 0x00 || pes[2] != 0x01)
+    {
+        if (bytevec_append(main_pes, pes, pes_len) != VLC_SUCCESS)
+            return VLC_ENOMEM;
+        return VLC_SUCCESS;
+    }
+
+    size_t hdr_len = 9 + pes[8];
+    if (hdr_len > pes_len)
+    {
+        if (bytevec_append(main_pes, pes, pes_len) != VLC_SUCCESS)
+            return VLC_ENOMEM;
+        return VLC_SUCCESS;
+    }
+
+    bytevec_t main_payload = {0}, sub_payload = {0};
+    int ret = transform_adts_payload(pes + hdr_len, pes_len - hdr_len,
+                                     &main_payload, &sub_payload);
+    if (ret != VLC_SUCCESS)
+    {
+        bytevec_clear(&main_payload);
+        bytevec_clear(&sub_payload);
+        return ret;
+    }
+
+    if (bytevec_append(main_pes, pes, hdr_len) != VLC_SUCCESS ||
+        bytevec_append(main_pes, main_payload.p, main_payload.len) != VLC_SUCCESS)
+    {
+        bytevec_clear(&main_payload);
+        bytevec_clear(&sub_payload);
+        return VLC_ENOMEM;
+    }
+
+    if (main_pes->len >= 6)
+    {
+        size_t plen = main_pes->len - 6;
+        if (plen <= UINT16_MAX)
+        {
+            main_pes->p[4] = (uint8_t)(plen >> 8);
+            main_pes->p[5] = (uint8_t)plen;
+        }
+    }
+
+    if (sub_payload.len > 0)
+    {
+        if (bytevec_append(sub_pes, pes, hdr_len) != VLC_SUCCESS ||
+            bytevec_append(sub_pes, sub_payload.p, sub_payload.len) != VLC_SUCCESS)
+        {
+            bytevec_clear(&main_payload);
+            bytevec_clear(&sub_payload);
+            return VLC_ENOMEM;
+        }
+        if (sub_pes->len >= 6)
+        {
+            size_t plen = sub_pes->len - 6;
+            if (plen <= UINT16_MAX)
+            {
+                sub_pes->p[4] = (uint8_t)(plen >> 8);
+                sub_pes->p[5] = (uint8_t)plen;
+            }
+        }
+    }
+
+    bytevec_clear(&main_payload);
+    bytevec_clear(&sub_payload);
+    return VLC_SUCCESS;
+}
+
+static int process_completed_pes(stream_t *s, stream_sys_t *sys,
+                                 int which, bool allow_sub)
+{
+    pes_assembler_t *a = (which == 1) ? &sys->pes1 : &sys->pes2;
+    if (!a->started || a->buf.len == 0)
+        return VLC_SUCCESS;
+
+    int ret = VLC_SUCCESS;
+    bytevec_t main_pes = {0}, sub_pes = {0};
+    bool detected_now = false;
+
+    if (!sys->dualmono_detected && allow_sub)
+    {
+        ret = rewrite_pes_payload(a->buf.p, a->buf.len, &main_pes, &sub_pes);
+        if (ret != VLC_SUCCESS)
+            goto out;
+        if (sub_pes.len > 0)
+            detected_now = true;
+    }
+    else if (sys->dualmono_detected)
+    {
+        ret = rewrite_pes_payload(a->buf.p, a->buf.len, &main_pes, &sub_pes);
+        if (ret != VLC_SUCCESS)
+            goto out;
+    }
+
+    if (detected_now)
+    {
+        sys->dualmono_detected = true;
+        msg_Dbg(s, "dualmono detected on AAC PID %d", sys->aac_pid1);
+
+        if (emit_pes_packets(&sys->out, sys->mapped_pid1, &sys->mapped_cc1,
+                             main_pes.p, main_pes.len) != VLC_SUCCESS)
+        {
+            ret = VLC_ENOMEM;
+            goto out;
+        }
+        if (emit_pes_packets(&sys->out, sys->mapped_pid2, &sys->mapped_cc2,
+                             sub_pes.p, sub_pes.len) != VLC_SUCCESS)
+        {
+            ret = VLC_ENOMEM;
+            goto out;
+        }
+    }
+    else if (sys->dualmono_detected)
+    {
+        uint16_t out_pid = (which == 1) ? sys->mapped_pid1 : sys->mapped_pid2;
+        uint8_t *cc = (which == 1) ? &sys->mapped_cc1 : &sys->mapped_cc2;
+        if (emit_pes_packets(&sys->out, out_pid, cc, main_pes.p, main_pes.len) != VLC_SUCCESS)
+        {
+            ret = VLC_ENOMEM;
+            goto out;
+        }
+    }
+    else
+    {
+        uint16_t out_pid = (uint16_t)((which == 1) ? sys->aac_pid1 : sys->aac_pid2);
+        uint8_t *cc = (which == 1) ? &sys->passthrough_cc1 : &sys->passthrough_cc2;
+        if (emit_pes_packets(&sys->out, out_pid, cc, a->buf.p, a->buf.len) != VLC_SUCCESS)
+        {
+            ret = VLC_ENOMEM;
+            goto out;
+        }
+    }
+
+out:
+    if (ret != VLC_SUCCESS)
+        msg_Warn(s, "failed to process PES for PID %d", (which == 1) ? sys->aac_pid1 : sys->aac_pid2);
+
+    a->started = false;
+    bytevec_reset(&a->buf);
+    bytevec_clear(&main_pes);
+    bytevec_clear(&sub_pes);
+    return ret;
+}
+
+static int process_ts_packet(stream_t *s, stream_sys_t *sys, const uint8_t *pkt)
+{
+    if (pkt[0] != TS_SYNC_BYTE)
+        return VLC_EGENERIC;
+
+    bool pusi = (pkt[1] & 0x40) != 0;
+    uint16_t pid = ((pkt[1] & 0x1f) << 8) | pkt[2];
+    uint8_t afc = (pkt[3] >> 4) & 0x3;
+
+    bool has_payload = (afc & 0x1) != 0;
+    size_t payload_off = 4;
+    if (afc & 0x2)
+    {
+        if (payload_off >= TS_PACKET_SIZE)
+            return VLC_EGENERIC;
+        uint8_t af_len = pkt[payload_off++];
+        payload_off += af_len;
+        if (payload_off > TS_PACKET_SIZE)
+            return VLC_EGENERIC;
+    }
+
+    const uint8_t *payload = has_payload ? (pkt + payload_off) : NULL;
+    size_t payload_len = has_payload ? (TS_PACKET_SIZE - payload_off) : 0;
+
+    if (pid == 0x0000 && has_payload && pusi && payload_len > 0)
+    {
+        uint8_t pointer = payload[0];
+        if ((size_t)pointer + 1 < payload_len)
+        {
+            const uint8_t *sec = payload + 1 + pointer;
+            size_t sec_avail = payload_len - 1 - pointer;
+            if (sec_avail >= 3)
+            {
+                size_t sec_len = 3 + (((sec[1] & 0x0f) << 8) | sec[2]);
+                if (sec_len <= sec_avail)
+                {
+                    int pmt_pid;
+                    if (parse_pat_find_pmt(sec, sec_len, &pmt_pid))
+                        sys->pmt_pid = pmt_pid;
+                }
+            }
+        }
+
+        if (bytevec_append(&sys->out, pkt, TS_PACKET_SIZE) != VLC_SUCCESS)
+            return VLC_ENOMEM;
+        return VLC_SUCCESS;
+    }
+
+    if (sys->pmt_pid >= 0 && pid == (uint16_t)sys->pmt_pid)
+    {
+        if (pusi)
+        {
+            sys->pmt_collecting = false;
+            sys->pmt_expected_len = 0;
+            bytevec_reset(&sys->pmt_section);
+        }
+
+        if (has_payload && payload_len > 0)
+        {
+            const uint8_t *section_data = payload;
+            size_t section_avail = payload_len;
+
+            if (pusi)
+            {
+                uint8_t pointer = payload[0];
+                if ((size_t)pointer + 1 >= payload_len)
+                {
+                    if (bytevec_append(&sys->out, pkt, TS_PACKET_SIZE) != VLC_SUCCESS)
+                        return VLC_ENOMEM;
+                    return VLC_SUCCESS;
+                }
+
+                section_data = payload + 1 + pointer;
+                section_avail = payload_len - 1 - pointer;
+            }
+
+            if (section_avail > 0)
+            {
+                if (!sys->pmt_collecting)
+                {
+                    if (section_avail >= 3)
+                    {
+                        sys->pmt_expected_len =
+                            3 + (((section_data[1] & 0x0f) << 8) | section_data[2]);
+                        if (sys->pmt_expected_len >= 3 && sys->pmt_expected_len <= 1024)
+                            sys->pmt_collecting = true;
+                    }
+                }
+
+                if (sys->pmt_collecting)
+                {
+                    size_t need = sys->pmt_expected_len > sys->pmt_section.len
+                                  ? sys->pmt_expected_len - sys->pmt_section.len : 0;
+                    size_t n = __MIN(need, section_avail);
+                    if (n > 0 && bytevec_append(&sys->pmt_section, section_data, n) != VLC_SUCCESS)
+                        return VLC_ENOMEM;
+
+                    if (sys->pmt_section.len >= sys->pmt_expected_len)
+                    {
+                        if (sys->pmt_expected_len >= 8)
+                        {
+                            const uint8_t *pmt = sys->pmt_section.p;
+                            uint16_t program_number = ((uint16_t)pmt[3] << 8) | pmt[4];
+                            uint8_t version = (pmt[5] >> 1) & 0x1f;
+                            if (sys->have_pmt_identity &&
+                                (sys->pmt_program_number != program_number ||
+                                 sys->pmt_version != version))
+                            {
+                                msg_Dbg(s, "dualmono: PMT changed (program=%u->%u version=%u->%u), reset state",
+                                        sys->pmt_program_number, program_number,
+                                        sys->pmt_version, version);
+                                reset_dualmono_runtime_state(sys);
+                            }
+                            sys->have_pmt_identity = true;
+                            sys->pmt_program_number = program_number;
+                            sys->pmt_version = version;
+                        }
+
+                        bytevec_t new_pmt = {0};
+                        int ret = rebuild_pmt_section(s, sys, sys->pmt_section.p,
+                                                      sys->pmt_expected_len, &new_pmt);
+                        if (ret == VLC_SUCCESS)
+                        {
+                            msg_Dbg(s, "dualmono: PMT section rewritten (len=%zu)", new_pmt.len);
+                            if (emit_psi_section(&sys->out, pid, &sys->pmt_cc,
+                                                 new_pmt.p, new_pmt.len) != VLC_SUCCESS)
+                            {
+                                bytevec_clear(&new_pmt);
+                                return VLC_ENOMEM;
+                            }
+                        }
+                        else
+                        {
+                            msg_Warn(s, "dualmono: PMT rewrite failed, forwarding original PMT section");
+                            if (emit_psi_section(&sys->out, pid, &sys->pmt_cc,
+                                                 sys->pmt_section.p, sys->pmt_expected_len) != VLC_SUCCESS)
+                            {
+                                bytevec_clear(&new_pmt);
+                                return VLC_ENOMEM;
+                            }
+                        }
+                        bytevec_clear(&new_pmt);
+                        sys->pmt_collecting = false;
+                        sys->pmt_expected_len = 0;
+                        bytevec_reset(&sys->pmt_section);
+                    }
+                }
+            }
+        }
+        return VLC_SUCCESS;
+    }
+
+    if (sys->aac_pid1 >= 0 && pid == (uint16_t)sys->aac_pid1)
+    {
+        if (pusi)
+        {
+            if (process_completed_pes(s, sys, 1, sys->aac_pid2 < 0) != VLC_SUCCESS)
+                return VLC_EGENERIC;
+            sys->pes1.started = true;
+            bytevec_reset(&sys->pes1.buf);
+        }
+
+        if (sys->pes1.started && has_payload && payload_len > 0)
+        {
+            if (bytevec_append(&sys->pes1.buf, payload, payload_len) != VLC_SUCCESS)
+                return VLC_ENOMEM;
+        }
+        return VLC_SUCCESS;
+    }
+
+    if (sys->aac_pid2 >= 0 && pid == (uint16_t)sys->aac_pid2)
+    {
+        if (pusi)
+        {
+            if (process_completed_pes(s, sys, 2, false) != VLC_SUCCESS)
+                return VLC_EGENERIC;
+            sys->pes2.started = true;
+            bytevec_reset(&sys->pes2.buf);
+        }
+
+        if (sys->pes2.started && has_payload && payload_len > 0)
+        {
+            if (bytevec_append(&sys->pes2.buf, payload, payload_len) != VLC_SUCCESS)
+                return VLC_ENOMEM;
+        }
+        return VLC_SUCCESS;
+    }
+
+    if (bytevec_append(&sys->out, pkt, TS_PACKET_SIZE) != VLC_SUCCESS)
+        return VLC_ENOMEM;
+
+    return VLC_SUCCESS;
+}
+
+static int process_input_buffer(stream_t *s, stream_sys_t *sys)
+{
+    while (sys->in.len >= TS_PACKET_SIZE)
+    {
+        if (sys->in.p[0] != TS_SYNC_BYTE)
+        {
+            size_t sync = 1;
+            while (sync < sys->in.len && sys->in.p[sync] != TS_SYNC_BYTE)
+                sync++;
+            bytevec_consume(&sys->in, sync);
+            continue;
+        }
+
+        int ret = process_ts_packet(s, sys, sys->in.p);
+        bytevec_consume(&sys->in, TS_PACKET_SIZE);
+        if (ret != VLC_SUCCESS)
+            return ret;
+    }
+    return VLC_SUCCESS;
+}
+
+static ssize_t Read(stream_t *s, void *buf, size_t len)
+{
+    stream_sys_t *sys = s->p_sys;
+    uint8_t *dst = buf;
+
+    if (len == 0)
+        return 0;
+
+    while (sys->out.len < len)
+    {
+        if (sys->upstream_eof)
+            break;
+
+        uint8_t tmp[TS_PACKET_SIZE * 64];
+        ssize_t r = vlc_stream_Read(s->s, tmp, sizeof(tmp));
+        if (r <= 0)
+        {
+            sys->upstream_eof = true;
+            break;
+        }
+
+        if (bytevec_append(&sys->in, tmp, (size_t)r) != VLC_SUCCESS)
+            return -1;
+
+        if (process_input_buffer(s, sys) != VLC_SUCCESS)
+            return -1;
+    }
+
+    if (sys->upstream_eof && !sys->flushed_eof)
+    {
+        if (process_completed_pes(s, sys, 1, sys->aac_pid2 < 0) != VLC_SUCCESS)
+            return -1;
+        if (process_completed_pes(s, sys, 2, false) != VLC_SUCCESS)
+            return -1;
+        sys->flushed_eof = true;
+    }
+
+    if (sys->out.len == 0)
+        return 0;
+
+    size_t n = __MIN(len, sys->out.len);
+    memcpy(dst, sys->out.p, n);
+    bytevec_consume(&sys->out, n);
+    return (ssize_t)n;
+}
+
+static int Seek(stream_t *s, uint64_t pos)
+{
+    stream_sys_t *sys = s->p_sys;
+
+    int ret = vlc_stream_Seek(s->s, pos);
+    if (ret != VLC_SUCCESS)
+        return ret;
+
+    bytevec_reset(&sys->in);
+    bytevec_reset(&sys->out);
+    bytevec_reset(&sys->pes1.buf);
+    bytevec_reset(&sys->pes2.buf);
+    bytevec_reset(&sys->pmt_section);
+    sys->pes1.started = false;
+    sys->pes2.started = false;
+    sys->upstream_eof = false;
+    sys->flushed_eof = false;
+    sys->pmt_pid = -1;
+    reset_dualmono_runtime_state(sys);
+    sys->have_pmt_identity = false;
+    sys->pmt_program_number = 0;
+    sys->pmt_version = 0;
+    sys->pmt_collecting = false;
+    sys->pmt_expected_len = 0;
+
+    return VLC_SUCCESS;
+}
+
+static int Control(stream_t *s, int query, va_list args)
+{
+    return vlc_stream_vaControl(s->s, query, args);
+}
+
+static int Open(vlc_object_t *obj)
+{
+    stream_t *s = (stream_t *)obj;
+
+    if (!is_likely_mpegts(s))
+        return VLC_EGENERIC;
+
+    stream_sys_t *sys = calloc(1, sizeof(*sys));
+    if (!sys)
+        return VLC_ENOMEM;
+
+    sys->pmt_pid = -1;
+    sys->aac_pid1 = -1;
+    sys->aac_pid2 = -1;
+    sys->mapped_pid1 = (uint16_t)var_InheritInteger(s, "aacdualmono-pid1");
+    sys->mapped_pid2 = (uint16_t)var_InheritInteger(s, "aacdualmono-pid2");
+    sys->pmt_cc = 0;
+    sys->mapped_cc1 = 0;
+    sys->mapped_cc2 = 0;
+    sys->passthrough_cc1 = 0;
+    sys->passthrough_cc2 = 0;
+    sys->dualmono_detected = false;
+    sys->have_pmt_identity = false;
+    sys->pmt_program_number = 0;
+    sys->pmt_version = 0;
+    sys->pmt_collecting = false;
+    sys->pmt_expected_len = 0;
+
+    if (sys->mapped_pid1 == 0 || sys->mapped_pid1 > 0x1ffe ||
+        sys->mapped_pid2 == 0 || sys->mapped_pid2 > 0x1ffe ||
+        sys->mapped_pid1 == sys->mapped_pid2)
+    {
+        free(sys);
+        return VLC_EGENERIC;
+    }
+
+    s->p_sys = sys;
+    s->pf_read = Read;
+    s->pf_seek = Seek;
+    s->pf_control = Control;
+
+    msg_Dbg(s, "aacdualmono initialized (PID1=%u PID2=%u)",
+            sys->mapped_pid1, sys->mapped_pid2);
+
+    return VLC_SUCCESS;
+}
+
+static void Close(vlc_object_t *obj)
+{
+    stream_t *s = (stream_t *)obj;
+    stream_sys_t *sys = s->p_sys;
+
+    bytevec_clear(&sys->in);
+    bytevec_clear(&sys->out);
+    bytevec_clear(&sys->pes1.buf);
+    bytevec_clear(&sys->pes2.buf);
+    bytevec_clear(&sys->pmt_section);
+
+    free(sys);
+}
diff --git a/modules/stream_filter/dualmono_aac_tables.h b/modules/stream_filter/dualmono_aac_tables.h
new file mode 100644
index 0000000000..8eb1e8670d
--- /dev/null
+++ b/modules/stream_filter/dualmono_aac_tables.h
@@ -0,0 +1,1451 @@
+/*
+MIT License
+
+Copyright (c) 2021 もにょ～ん
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+*/
+#ifndef VLC_DUALMONO_AAC_TABLES_H
+#define VLC_DUALMONO_AAC_TABLES_H
+
+typedef struct { uint32_t code; uint8_t len; } huff_entry_t;
+
+static const huff_entry_t scalefactor_table[121] = {
+    { 0x3ffe8, 18 },
+    { 0x3ffe6, 18 },
+    { 0x3ffe7, 18 },
+    { 0x3ffe5, 18 },
+    { 0x7fff5, 19 },
+    { 0x7fff1, 19 },
+    { 0x7ffed, 19 },
+    { 0x7fff6, 19 },
+    { 0x7ffee, 19 },
+    { 0x7ffef, 19 },
+    { 0x7fff0, 19 },
+    { 0x7fffc, 19 },
+    { 0x7fffd, 19 },
+    { 0x7ffff, 19 },
+    { 0x7fffe, 19 },
+    { 0x7fff7, 19 },
+    { 0x7fff8, 19 },
+    { 0x7fffb, 19 },
+    { 0x7fff9, 19 },
+    { 0x3ffe4, 18 },
+    { 0x7fffa, 19 },
+    { 0x3ffe3, 18 },
+    { 0x1ffef, 17 },
+    { 0x1fff0, 17 },
+    { 0xfff5, 16 },
+    { 0x1ffee, 17 },
+    { 0xfff2, 16 },
+    { 0xfff3, 16 },
+    { 0xfff4, 16 },
+    { 0xfff1, 16 },
+    { 0x7ff6, 15 },
+    { 0x7ff7, 15 },
+    { 0x3ff9, 14 },
+    { 0x3ff5, 14 },
+    { 0x3ff7, 14 },
+    { 0x3ff3, 14 },
+    { 0x3ff6, 14 },
+    { 0x3ff2, 14 },
+    { 0x1ff7, 13 },
+    { 0x1ff5, 13 },
+    { 0xff9, 12 },
+    { 0xff7, 12 },
+    { 0xff6, 12 },
+    { 0x7f9, 11 },
+    { 0xff4, 12 },
+    { 0x7f8, 11 },
+    { 0x3f9, 10 },
+    { 0x3f7, 10 },
+    { 0x3f5, 10 },
+    { 0x1f8, 9 },
+    { 0x1f7, 9 },
+    { 0xfa, 8 },
+    { 0xf8, 8 },
+    { 0xf6, 8 },
+    { 0x79, 7 },
+    { 0x3a, 6 },
+    { 0x38, 6 },
+    { 0x1a, 5 },
+    { 0xb, 4 },
+    { 0x4, 3 },
+    { 0x0, 1 },
+    { 0xa, 4 },
+    { 0xc, 4 },
+    { 0x1b, 5 },
+    { 0x39, 6 },
+    { 0x3b, 6 },
+    { 0x78, 7 },
+    { 0x7a, 7 },
+    { 0xf7, 8 },
+    { 0xf9, 8 },
+    { 0x1f6, 9 },
+    { 0x1f9, 9 },
+    { 0x3f4, 10 },
+    { 0x3f6, 10 },
+    { 0x3f8, 10 },
+    { 0x7f5, 11 },
+    { 0x7f4, 11 },
+    { 0x7f6, 11 },
+    { 0x7f7, 11 },
+    { 0xff5, 12 },
+    { 0xff8, 12 },
+    { 0x1ff4, 13 },
+    { 0x1ff6, 13 },
+    { 0x1ff8, 13 },
+    { 0x3ff8, 14 },
+    { 0x3ff4, 14 },
+    { 0xfff0, 16 },
+    { 0x7ff4, 15 },
+    { 0xfff6, 16 },
+    { 0x7ff5, 15 },
+    { 0x3ffe2, 18 },
+    { 0x7ffd9, 19 },
+    { 0x7ffda, 19 },
+    { 0x7ffdb, 19 },
+    { 0x7ffdc, 19 },
+    { 0x7ffdd, 19 },
+    { 0x7ffde, 19 },
+    { 0x7ffd8, 19 },
+    { 0x7ffd2, 19 },
+    { 0x7ffd3, 19 },
+    { 0x7ffd4, 19 },
+    { 0x7ffd5, 19 },
+    { 0x7ffd6, 19 },
+    { 0x7fff2, 19 },
+    { 0x7ffdf, 19 },
+    { 0x7ffe7, 19 },
+    { 0x7ffe8, 19 },
+    { 0x7ffe9, 19 },
+    { 0x7ffea, 19 },
+    { 0x7ffeb, 19 },
+    { 0x7ffe6, 19 },
+    { 0x7ffe0, 19 },
+    { 0x7ffe1, 19 },
+    { 0x7ffe2, 19 },
+    { 0x7ffe3, 19 },
+    { 0x7ffe4, 19 },
+    { 0x7ffe5, 19 },
+    { 0x7ffd7, 19 },
+    { 0x7ffec, 19 },
+    { 0x7fff4, 19 },
+    { 0x7fff3, 19 },
+};
+
+#define SCALEFACTOR_TABLE_SIZE 121u
+
+static const huff_entry_t spectrum1_table[81] = {
+    { 0x7f8, 11 },
+    { 0x1f1, 9 },
+    { 0x7fd, 11 },
+    { 0x3f5, 10 },
+    { 0x68, 7 },
+    { 0x3f0, 10 },
+    { 0x7f7, 11 },
+    { 0x1ec, 9 },
+    { 0x7f5, 11 },
+    { 0x3f1, 10 },
+    { 0x72, 7 },
+    { 0x3f4, 10 },
+    { 0x74, 7 },
+    { 0x11, 5 },
+    { 0x76, 7 },
+    { 0x1eb, 9 },
+    { 0x6c, 7 },
+    { 0x3f6, 10 },
+    { 0x7fc, 11 },
+    { 0x1e1, 9 },
+    { 0x7f1, 11 },
+    { 0x1f0, 9 },
+    { 0x61, 7 },
+    { 0x1f6, 9 },
+    { 0x7f2, 11 },
+    { 0x1ea, 9 },
+    { 0x7fb, 11 },
+    { 0x1f2, 9 },
+    { 0x69, 7 },
+    { 0x1ed, 9 },
+    { 0x77, 7 },
+    { 0x17, 5 },
+    { 0x6f, 7 },
+    { 0x1e6, 9 },
+    { 0x64, 7 },
+    { 0x1e5, 9 },
+    { 0x67, 7 },
+    { 0x15, 5 },
+    { 0x62, 7 },
+    { 0x12, 5 },
+    { 0x0, 1 },
+    { 0x14, 5 },
+    { 0x65, 7 },
+    { 0x16, 5 },
+    { 0x6d, 7 },
+    { 0x1e9, 9 },
+    { 0x63, 7 },
+    { 0x1e4, 9 },
+    { 0x6b, 7 },
+    { 0x13, 5 },
+    { 0x71, 7 },
+    { 0x1e3, 9 },
+    { 0x70, 7 },
+    { 0x1f3, 9 },
+    { 0x7fe, 11 },
+    { 0x1e7, 9 },
+    { 0x7f3, 11 },
+    { 0x1ef, 9 },
+    { 0x60, 7 },
+    { 0x1ee, 9 },
+    { 0x7f0, 11 },
+    { 0x1e2, 9 },
+    { 0x7fa, 11 },
+    { 0x3f3, 10 },
+    { 0x6a, 7 },
+    { 0x1e8, 9 },
+    { 0x75, 7 },
+    { 0x10, 5 },
+    { 0x73, 7 },
+    { 0x1f4, 9 },
+    { 0x6e, 7 },
+    { 0x3f7, 10 },
+    { 0x7f6, 11 },
+    { 0x1e0, 9 },
+    { 0x7f9, 11 },
+    { 0x3f2, 10 },
+    { 0x66, 7 },
+    { 0x1f5, 9 },
+    { 0x7ff, 11 },
+    { 0x1f7, 9 },
+    { 0x7f4, 11 },
+};
+
+#define SPECTRUM1_TABLE_SIZE 81u
+
+static const huff_entry_t spectrum2_table[81] = {
+    { 0x1f3, 9 },
+    { 0x6f, 7 },
+    { 0x1fd, 9 },
+    { 0xeb, 8 },
+    { 0x23, 6 },
+    { 0xea, 8 },
+    { 0x1f7, 9 },
+    { 0xe8, 8 },
+    { 0x1fa, 9 },
+    { 0xf2, 8 },
+    { 0x2d, 6 },
+    { 0x70, 7 },
+    { 0x20, 6 },
+    { 0x6, 5 },
+    { 0x2b, 6 },
+    { 0x6e, 7 },
+    { 0x28, 6 },
+    { 0xe9, 8 },
+    { 0x1f9, 9 },
+    { 0x66, 7 },
+    { 0xf8, 8 },
+    { 0xe7, 8 },
+    { 0x1b, 6 },
+    { 0xf1, 8 },
+    { 0x1f4, 9 },
+    { 0x6b, 7 },
+    { 0x1f5, 9 },
+    { 0xec, 8 },
+    { 0x2a, 6 },
+    { 0x6c, 7 },
+    { 0x2c, 6 },
+    { 0xa, 5 },
+    { 0x27, 6 },
+    { 0x67, 7 },
+    { 0x1a, 6 },
+    { 0xf5, 8 },
+    { 0x24, 6 },
+    { 0x8, 5 },
+    { 0x1f, 6 },
+    { 0x9, 5 },
+    { 0x0, 3 },
+    { 0x7, 5 },
+    { 0x1d, 6 },
+    { 0xb, 5 },
+    { 0x30, 6 },
+    { 0xef, 8 },
+    { 0x1c, 6 },
+    { 0x64, 7 },
+    { 0x1e, 6 },
+    { 0xc, 5 },
+    { 0x29, 6 },
+    { 0xf3, 8 },
+    { 0x2f, 6 },
+    { 0xf0, 8 },
+    { 0x1fc, 9 },
+    { 0x71, 7 },
+    { 0x1f2, 9 },
+    { 0xf4, 8 },
+    { 0x21, 6 },
+    { 0xe6, 8 },
+    { 0xf7, 8 },
+    { 0x68, 7 },
+    { 0x1f8, 9 },
+    { 0xee, 8 },
+    { 0x22, 6 },
+    { 0x65, 7 },
+    { 0x31, 6 },
+    { 0x2, 4 },
+    { 0x26, 6 },
+    { 0xed, 8 },
+    { 0x25, 6 },
+    { 0x6a, 7 },
+    { 0x1fb, 9 },
+    { 0x72, 7 },
+    { 0x1fe, 9 },
+    { 0x69, 7 },
+    { 0x2e, 6 },
+    { 0xf6, 8 },
+    { 0x1ff, 9 },
+    { 0x6d, 7 },
+    { 0x1f6, 9 },
+};
+
+#define SPECTRUM2_TABLE_SIZE 81u
+
+static const huff_entry_t spectrum3_table[81] = {
+    { 0x0, 1 },
+    { 0x9, 4 },
+    { 0xef, 8 },
+    { 0xb, 4 },
+    { 0x19, 5 },
+    { 0xf0, 8 },
+    { 0x1eb, 9 },
+    { 0x1e6, 9 },
+    { 0x3f2, 10 },
+    { 0xa, 4 },
+    { 0x35, 6 },
+    { 0x1ef, 9 },
+    { 0x34, 6 },
+    { 0x37, 6 },
+    { 0x1e9, 9 },
+    { 0x1ed, 9 },
+    { 0x1e7, 9 },
+    { 0x3f3, 10 },
+    { 0x1ee, 9 },
+    { 0x3ed, 10 },
+    { 0x1ffa, 13 },
+    { 0x1ec, 9 },
+    { 0x1f2, 9 },
+    { 0x7f9, 11 },
+    { 0x7f8, 11 },
+    { 0x3f8, 10 },
+    { 0xff8, 12 },
+    { 0x8, 4 },
+    { 0x38, 6 },
+    { 0x3f6, 10 },
+    { 0x36, 6 },
+    { 0x75, 7 },
+    { 0x3f1, 10 },
+    { 0x3eb, 10 },
+    { 0x3ec, 10 },
+    { 0xff4, 12 },
+    { 0x18, 5 },
+    { 0x76, 7 },
+    { 0x7f4, 11 },
+    { 0x39, 6 },
+    { 0x74, 7 },
+    { 0x3ef, 10 },
+    { 0x1f3, 9 },
+    { 0x1f4, 9 },
+    { 0x7f6, 11 },
+    { 0x1e8, 9 },
+    { 0x3ea, 10 },
+    { 0x1ffc, 13 },
+    { 0xf2, 8 },
+    { 0x1f1, 9 },
+    { 0xffb, 12 },
+    { 0x3f5, 10 },
+    { 0x7f3, 11 },
+    { 0xffc, 12 },
+    { 0xee, 8 },
+    { 0x3f7, 10 },
+    { 0x7ffe, 15 },
+    { 0x1f0, 9 },
+    { 0x7f5, 11 },
+    { 0x7ffd, 15 },
+    { 0x1ffb, 13 },
+    { 0x3ffa, 14 },
+    { 0xffff, 16 },
+    { 0xf1, 8 },
+    { 0x3f0, 10 },
+    { 0x3ffc, 14 },
+    { 0x1ea, 9 },
+    { 0x3ee, 10 },
+    { 0x3ffb, 14 },
+    { 0xff6, 12 },
+    { 0xffa, 12 },
+    { 0x7ffc, 15 },
+    { 0x7f2, 11 },
+    { 0xff5, 12 },
+    { 0xfffe, 16 },
+    { 0x3f4, 10 },
+    { 0x7f7, 11 },
+    { 0x7ffb, 15 },
+    { 0xff7, 12 },
+    { 0xff9, 12 },
+    { 0x7ffa, 15 },
+};
+
+#define SPECTRUM3_TABLE_SIZE 81u
+
+static const huff_entry_t spectrum4_table[81] = {
+    { 0x7, 4 },
+    { 0x16, 5 },
+    { 0xf6, 8 },
+    { 0x18, 5 },
+    { 0x8, 4 },
+    { 0xef, 8 },
+    { 0x1ef, 9 },
+    { 0xf3, 8 },
+    { 0x7f8, 11 },
+    { 0x19, 5 },
+    { 0x17, 5 },
+    { 0xed, 8 },
+    { 0x15, 5 },
+    { 0x1, 4 },
+    { 0xe2, 8 },
+    { 0xf0, 8 },
+    { 0x70, 7 },
+    { 0x3f0, 10 },
+    { 0x1ee, 9 },
+    { 0xf1, 8 },
+    { 0x7fa, 11 },
+    { 0xee, 8 },
+    { 0xe4, 8 },
+    { 0x3f2, 10 },
+    { 0x7f6, 11 },
+    { 0x3ef, 10 },
+    { 0x7fd, 11 },
+    { 0x5, 4 },
+    { 0x14, 5 },
+    { 0xf2, 8 },
+    { 0x9, 4 },
+    { 0x4, 4 },
+    { 0xe5, 8 },
+    { 0xf4, 8 },
+    { 0xe8, 8 },
+    { 0x3f4, 10 },
+    { 0x6, 4 },
+    { 0x2, 4 },
+    { 0xe7, 8 },
+    { 0x3, 4 },
+    { 0x0, 4 },
+    { 0x6b, 7 },
+    { 0xe3, 8 },
+    { 0x69, 7 },
+    { 0x1f3, 9 },
+    { 0xeb, 8 },
+    { 0xe6, 8 },
+    { 0x3f6, 10 },
+    { 0x6e, 7 },
+    { 0x6a, 7 },
+    { 0x1f4, 9 },
+    { 0x3ec, 10 },
+    { 0x1f0, 9 },
+    { 0x3f9, 10 },
+    { 0xf5, 8 },
+    { 0xec, 8 },
+    { 0x7fb, 11 },
+    { 0xea, 8 },
+    { 0x6f, 7 },
+    { 0x3f7, 10 },
+    { 0x7f9, 11 },
+    { 0x3f3, 10 },
+    { 0xfff, 12 },
+    { 0xe9, 8 },
+    { 0x6d, 7 },
+    { 0x3f8, 10 },
+    { 0x6c, 7 },
+    { 0x68, 7 },
+    { 0x1f5, 9 },
+    { 0x3ee, 10 },
+    { 0x1f2, 9 },
+    { 0x7f4, 11 },
+    { 0x7f7, 11 },
+    { 0x3f1, 10 },
+    { 0xffe, 12 },
+    { 0x3ed, 10 },
+    { 0x1f1, 9 },
+    { 0x7f5, 11 },
+    { 0x7fe, 11 },
+    { 0x3f5, 10 },
+    { 0x7fc, 11 },
+};
+
+#define SPECTRUM4_TABLE_SIZE 81u
+
+static const huff_entry_t spectrum5_table[81] = {
+    { 0x1fff, 13 },
+    { 0xff7, 12 },
+    { 0x7f4, 11 },
+    { 0x7e8, 11 },
+    { 0x3f1, 10 },
+    { 0x7ee, 11 },
+    { 0x7f9, 11 },
+    { 0xff8, 12 },
+    { 0x1ffd, 13 },
+    { 0xffd, 12 },
+    { 0x7f1, 11 },
+    { 0x3e8, 10 },
+    { 0x1e8, 9 },
+    { 0xf0, 8 },
+    { 0x1ec, 9 },
+    { 0x3ee, 10 },
+    { 0x7f2, 11 },
+    { 0xffa, 12 },
+    { 0xff4, 12 },
+    { 0x3ef, 10 },
+    { 0x1f2, 9 },
+    { 0xe8, 8 },
+    { 0x70, 7 },
+    { 0xec, 8 },
+    { 0x1f0, 9 },
+    { 0x3ea, 10 },
+    { 0x7f3, 11 },
+    { 0x7eb, 11 },
+    { 0x1eb, 9 },
+    { 0xea, 8 },
+    { 0x1a, 5 },
+    { 0x8, 4 },
+    { 0x19, 5 },
+    { 0xee, 8 },
+    { 0x1ef, 9 },
+    { 0x7ed, 11 },
+    { 0x3f0, 10 },
+    { 0xf2, 8 },
+    { 0x73, 7 },
+    { 0xb, 4 },
+    { 0x0, 1 },
+    { 0xa, 4 },
+    { 0x71, 7 },
+    { 0xf3, 8 },
+    { 0x7e9, 11 },
+    { 0x7ef, 11 },
+    { 0x1ee, 9 },
+    { 0xef, 8 },
+    { 0x18, 5 },
+    { 0x9, 4 },
+    { 0x1b, 5 },
+    { 0xeb, 8 },
+    { 0x1e9, 9 },
+    { 0x7ec, 11 },
+    { 0x7f6, 11 },
+    { 0x3eb, 10 },
+    { 0x1f3, 9 },
+    { 0xed, 8 },
+    { 0x72, 7 },
+    { 0xe9, 8 },
+    { 0x1f1, 9 },
+    { 0x3ed, 10 },
+    { 0x7f7, 11 },
+    { 0xff6, 12 },
+    { 0x7f0, 11 },
+    { 0x3e9, 10 },
+    { 0x1ed, 9 },
+    { 0xf1, 8 },
+    { 0x1ea, 9 },
+    { 0x3ec, 10 },
+    { 0x7f8, 11 },
+    { 0xff9, 12 },
+    { 0x1ffc, 13 },
+    { 0xffc, 12 },
+    { 0xff5, 12 },
+    { 0x7ea, 11 },
+    { 0x3f3, 10 },
+    { 0x3f2, 10 },
+    { 0x7f5, 11 },
+    { 0xffb, 12 },
+    { 0x1ffe, 13 },
+};
+
+#define SPECTRUM5_TABLE_SIZE 81u
+
+static const huff_entry_t spectrum6_table[81] = {
+    { 0x7fe, 11 },
+    { 0x3fd, 10 },
+    { 0x1f1, 9 },
+    { 0x1eb, 9 },
+    { 0x1f4, 9 },
+    { 0x1ea, 9 },
+    { 0x1f0, 9 },
+    { 0x3fc, 10 },
+    { 0x7fd, 11 },
+    { 0x3f6, 10 },
+    { 0x1e5, 9 },
+    { 0xea, 8 },
+    { 0x6c, 7 },
+    { 0x71, 7 },
+    { 0x68, 7 },
+    { 0xf0, 8 },
+    { 0x1e6, 9 },
+    { 0x3f7, 10 },
+    { 0x1f3, 9 },
+    { 0xef, 8 },
+    { 0x32, 6 },
+    { 0x27, 6 },
+    { 0x28, 6 },
+    { 0x26, 6 },
+    { 0x31, 6 },
+    { 0xeb, 8 },
+    { 0x1f7, 9 },
+    { 0x1e8, 9 },
+    { 0x6f, 7 },
+    { 0x2e, 6 },
+    { 0x8, 4 },
+    { 0x4, 4 },
+    { 0x6, 4 },
+    { 0x29, 6 },
+    { 0x6b, 7 },
+    { 0x1ee, 9 },
+    { 0x1ef, 9 },
+    { 0x72, 7 },
+    { 0x2d, 6 },
+    { 0x2, 4 },
+    { 0x0, 4 },
+    { 0x3, 4 },
+    { 0x2f, 6 },
+    { 0x73, 7 },
+    { 0x1fa, 9 },
+    { 0x1e7, 9 },
+    { 0x6e, 7 },
+    { 0x2b, 6 },
+    { 0x7, 4 },
+    { 0x1, 4 },
+    { 0x5, 4 },
+    { 0x2c, 6 },
+    { 0x6d, 7 },
+    { 0x1ec, 9 },
+    { 0x1f9, 9 },
+    { 0xee, 8 },
+    { 0x30, 6 },
+    { 0x24, 6 },
+    { 0x2a, 6 },
+    { 0x25, 6 },
+    { 0x33, 6 },
+    { 0xec, 8 },
+    { 0x1f2, 9 },
+    { 0x3f8, 10 },
+    { 0x1e4, 9 },
+    { 0xed, 8 },
+    { 0x6a, 7 },
+    { 0x70, 7 },
+    { 0x69, 7 },
+    { 0x74, 7 },
+    { 0xf1, 8 },
+    { 0x3fa, 10 },
+    { 0x7ff, 11 },
+    { 0x3f9, 10 },
+    { 0x1f6, 9 },
+    { 0x1ed, 9 },
+    { 0x1f8, 9 },
+    { 0x1e9, 9 },
+    { 0x1f5, 9 },
+    { 0x3fb, 10 },
+    { 0x7fc, 11 },
+};
+
+#define SPECTRUM6_TABLE_SIZE 81u
+
+static const huff_entry_t spectrum7_table[64] = {
+    { 0x0, 1 },
+    { 0x5, 3 },
+    { 0x37, 6 },
+    { 0x74, 7 },
+    { 0xf2, 8 },
+    { 0x1eb, 9 },
+    { 0x3ed, 10 },
+    { 0x7f7, 11 },
+    { 0x4, 3 },
+    { 0xc, 4 },
+    { 0x35, 6 },
+    { 0x71, 7 },
+    { 0xec, 8 },
+    { 0xee, 8 },
+    { 0x1ee, 9 },
+    { 0x1f5, 9 },
+    { 0x36, 6 },
+    { 0x34, 6 },
+    { 0x72, 7 },
+    { 0xea, 8 },
+    { 0xf1, 8 },
+    { 0x1e9, 9 },
+    { 0x1f3, 9 },
+    { 0x3f5, 10 },
+    { 0x73, 7 },
+    { 0x70, 7 },
+    { 0xeb, 8 },
+    { 0xf0, 8 },
+    { 0x1f1, 9 },
+    { 0x1f0, 9 },
+    { 0x3ec, 10 },
+    { 0x3fa, 10 },
+    { 0xf3, 8 },
+    { 0xed, 8 },
+    { 0x1e8, 9 },
+    { 0x1ef, 9 },
+    { 0x3ef, 10 },
+    { 0x3f1, 10 },
+    { 0x3f9, 10 },
+    { 0x7fb, 11 },
+    { 0x1ed, 9 },
+    { 0xef, 8 },
+    { 0x1ea, 9 },
+    { 0x1f2, 9 },
+    { 0x3f3, 10 },
+    { 0x3f8, 10 },
+    { 0x7f9, 11 },
+    { 0x7fc, 11 },
+    { 0x3ee, 10 },
+    { 0x1ec, 9 },
+    { 0x1f4, 9 },
+    { 0x3f4, 10 },
+    { 0x3f7, 10 },
+    { 0x7f8, 11 },
+    { 0xffd, 12 },
+    { 0xffe, 12 },
+    { 0x7f6, 11 },
+    { 0x3f0, 10 },
+    { 0x3f2, 10 },
+    { 0x3f6, 10 },
+    { 0x7fa, 11 },
+    { 0x7fd, 11 },
+    { 0xffc, 12 },
+    { 0xfff, 12 },
+};
+
+#define SPECTRUM7_TABLE_SIZE 64u
+
+static const huff_entry_t spectrum8_table[64] = {
+    { 0xe, 5 },
+    { 0x5, 4 },
+    { 0x10, 5 },
+    { 0x30, 6 },
+    { 0x6f, 7 },
+    { 0xf1, 8 },
+    { 0x1fa, 9 },
+    { 0x3fe, 10 },
+    { 0x3, 4 },
+    { 0x0, 3 },
+    { 0x4, 4 },
+    { 0x12, 5 },
+    { 0x2c, 6 },
+    { 0x6a, 7 },
+    { 0x75, 7 },
+    { 0xf8, 8 },
+    { 0xf, 5 },
+    { 0x2, 4 },
+    { 0x6, 4 },
+    { 0x14, 5 },
+    { 0x2e, 6 },
+    { 0x69, 7 },
+    { 0x72, 7 },
+    { 0xf5, 8 },
+    { 0x2f, 6 },
+    { 0x11, 5 },
+    { 0x13, 5 },
+    { 0x2a, 6 },
+    { 0x32, 6 },
+    { 0x6c, 7 },
+    { 0xec, 8 },
+    { 0xfa, 8 },
+    { 0x71, 7 },
+    { 0x2b, 6 },
+    { 0x2d, 6 },
+    { 0x31, 6 },
+    { 0x6d, 7 },
+    { 0x70, 7 },
+    { 0xf2, 8 },
+    { 0x1f9, 9 },
+    { 0xef, 8 },
+    { 0x68, 7 },
+    { 0x33, 6 },
+    { 0x6b, 7 },
+    { 0x6e, 7 },
+    { 0xee, 8 },
+    { 0xf9, 8 },
+    { 0x3fc, 10 },
+    { 0x1f8, 9 },
+    { 0x74, 7 },
+    { 0x73, 7 },
+    { 0xed, 8 },
+    { 0xf0, 8 },
+    { 0xf6, 8 },
+    { 0x1f6, 9 },
+    { 0x1fd, 9 },
+    { 0x3fd, 10 },
+    { 0xf3, 8 },
+    { 0xf4, 8 },
+    { 0xf7, 8 },
+    { 0x1f7, 9 },
+    { 0x1fb, 9 },
+    { 0x1fc, 9 },
+    { 0x3ff, 10 },
+};
+
+#define SPECTRUM8_TABLE_SIZE 64u
+
+static const huff_entry_t spectrum9_table[169] = {
+    { 0x0, 1 },
+    { 0x5, 3 },
+    { 0x37, 6 },
+    { 0xe7, 8 },
+    { 0x1de, 9 },
+    { 0x3ce, 10 },
+    { 0x3d9, 10 },
+    { 0x7c8, 11 },
+    { 0x7cd, 11 },
+    { 0xfc8, 12 },
+    { 0xfdd, 12 },
+    { 0x1fe4, 13 },
+    { 0x1fec, 13 },
+    { 0x4, 3 },
+    { 0xc, 4 },
+    { 0x35, 6 },
+    { 0x72, 7 },
+    { 0xea, 8 },
+    { 0xed, 8 },
+    { 0x1e2, 9 },
+    { 0x3d1, 10 },
+    { 0x3d3, 10 },
+    { 0x3e0, 10 },
+    { 0x7d8, 11 },
+    { 0xfcf, 12 },
+    { 0xfd5, 12 },
+    { 0x36, 6 },
+    { 0x34, 6 },
+    { 0x71, 7 },
+    { 0xe8, 8 },
+    { 0xec, 8 },
+    { 0x1e1, 9 },
+    { 0x3cf, 10 },
+    { 0x3dd, 10 },
+    { 0x3db, 10 },
+    { 0x7d0, 11 },
+    { 0xfc7, 12 },
+    { 0xfd4, 12 },
+    { 0xfe4, 12 },
+    { 0xe6, 8 },
+    { 0x70, 7 },
+    { 0xe9, 8 },
+    { 0x1dd, 9 },
+    { 0x1e3, 9 },
+    { 0x3d2, 10 },
+    { 0x3dc, 10 },
+    { 0x7cc, 11 },
+    { 0x7ca, 11 },
+    { 0x7de, 11 },
+    { 0xfd8, 12 },
+    { 0xfea, 12 },
+    { 0x1fdb, 13 },
+    { 0x1df, 9 },
+    { 0xeb, 8 },
+    { 0x1dc, 9 },
+    { 0x1e6, 9 },
+    { 0x3d5, 10 },
+    { 0x3de, 10 },
+    { 0x7cb, 11 },
+    { 0x7dd, 11 },
+    { 0x7dc, 11 },
+    { 0xfcd, 12 },
+    { 0xfe2, 12 },
+    { 0xfe7, 12 },
+    { 0x1fe1, 13 },
+    { 0x3d0, 10 },
+    { 0x1e0, 9 },
+    { 0x1e4, 9 },
+    { 0x3d6, 10 },
+    { 0x7c5, 11 },
+    { 0x7d1, 11 },
+    { 0x7db, 11 },
+    { 0xfd2, 12 },
+    { 0x7e0, 11 },
+    { 0xfd9, 12 },
+    { 0xfeb, 12 },
+    { 0x1fe3, 13 },
+    { 0x1fe9, 13 },
+    { 0x7c4, 11 },
+    { 0x1e5, 9 },
+    { 0x3d7, 10 },
+    { 0x7c6, 11 },
+    { 0x7cf, 11 },
+    { 0x7da, 11 },
+    { 0xfcb, 12 },
+    { 0xfda, 12 },
+    { 0xfe3, 12 },
+    { 0xfe9, 12 },
+    { 0x1fe6, 13 },
+    { 0x1ff3, 13 },
+    { 0x1ff7, 13 },
+    { 0x7d3, 11 },
+    { 0x3d8, 10 },
+    { 0x3e1, 10 },
+    { 0x7d4, 11 },
+    { 0x7d9, 11 },
+    { 0xfd3, 12 },
+    { 0xfde, 12 },
+    { 0x1fdd, 13 },
+    { 0x1fd9, 13 },
+    { 0x1fe2, 13 },
+    { 0x1fea, 13 },
+    { 0x1ff1, 13 },
+    { 0x1ff6, 13 },
+    { 0x7d2, 11 },
+    { 0x3d4, 10 },
+    { 0x3da, 10 },
+    { 0x7c7, 11 },
+    { 0x7d7, 11 },
+    { 0x7e2, 11 },
+    { 0xfce, 12 },
+    { 0xfdb, 12 },
+    { 0x1fd8, 13 },
+    { 0x1fee, 13 },
+    { 0x3ff0, 14 },
+    { 0x1ff4, 13 },
+    { 0x3ff2, 14 },
+    { 0x7e1, 11 },
+    { 0x3df, 10 },
+    { 0x7c9, 11 },
+    { 0x7d6, 11 },
+    { 0xfca, 12 },
+    { 0xfd0, 12 },
+    { 0xfe5, 12 },
+    { 0xfe6, 12 },
+    { 0x1feb, 13 },
+    { 0x1fef, 13 },
+    { 0x3ff3, 14 },
+    { 0x3ff4, 14 },
+    { 0x3ff5, 14 },
+    { 0xfe0, 12 },
+    { 0x7ce, 11 },
+    { 0x7d5, 11 },
+    { 0xfc6, 12 },
+    { 0xfd1, 12 },
+    { 0xfe1, 12 },
+    { 0x1fe0, 13 },
+    { 0x1fe8, 13 },
+    { 0x1ff0, 13 },
+    { 0x3ff1, 14 },
+    { 0x3ff8, 14 },
+    { 0x3ff6, 14 },
+    { 0x7ffc, 15 },
+    { 0xfe8, 12 },
+    { 0x7df, 11 },
+    { 0xfc9, 12 },
+    { 0xfd7, 12 },
+    { 0xfdc, 12 },
+    { 0x1fdc, 13 },
+    { 0x1fdf, 13 },
+    { 0x1fed, 13 },
+    { 0x1ff5, 13 },
+    { 0x3ff9, 14 },
+    { 0x3ffb, 14 },
+    { 0x7ffd, 15 },
+    { 0x7ffe, 15 },
+    { 0x1fe7, 13 },
+    { 0xfcc, 12 },
+    { 0xfd6, 12 },
+    { 0xfdf, 12 },
+    { 0x1fde, 13 },
+    { 0x1fda, 13 },
+    { 0x1fe5, 13 },
+    { 0x1ff2, 13 },
+    { 0x3ffa, 14 },
+    { 0x3ff7, 14 },
+    { 0x3ffc, 14 },
+    { 0x3ffd, 14 },
+    { 0x7fff, 15 },
+};
+
+#define SPECTRUM9_TABLE_SIZE 169u
+
+static const huff_entry_t spectrum10_table[169] = {
+    { 0x22, 6 },
+    { 0x8, 5 },
+    { 0x1d, 6 },
+    { 0x26, 6 },
+    { 0x5f, 7 },
+    { 0xd3, 8 },
+    { 0x1cf, 9 },
+    { 0x3d0, 10 },
+    { 0x3d7, 10 },
+    { 0x3ed, 10 },
+    { 0x7f0, 11 },
+    { 0x7f6, 11 },
+    { 0xffd, 12 },
+    { 0x7, 5 },
+    { 0x0, 4 },
+    { 0x1, 4 },
+    { 0x9, 5 },
+    { 0x20, 6 },
+    { 0x54, 7 },
+    { 0x60, 7 },
+    { 0xd5, 8 },
+    { 0xdc, 8 },
+    { 0x1d4, 9 },
+    { 0x3cd, 10 },
+    { 0x3de, 10 },
+    { 0x7e7, 11 },
+    { 0x1c, 6 },
+    { 0x2, 4 },
+    { 0x6, 5 },
+    { 0xc, 5 },
+    { 0x1e, 6 },
+    { 0x28, 6 },
+    { 0x5b, 7 },
+    { 0xcd, 8 },
+    { 0xd9, 8 },
+    { 0x1ce, 9 },
+    { 0x1dc, 9 },
+    { 0x3d9, 10 },
+    { 0x3f1, 10 },
+    { 0x25, 6 },
+    { 0xb, 5 },
+    { 0xa, 5 },
+    { 0xd, 5 },
+    { 0x24, 6 },
+    { 0x57, 7 },
+    { 0x61, 7 },
+    { 0xcc, 8 },
+    { 0xdd, 8 },
+    { 0x1cc, 9 },
+    { 0x1de, 9 },
+    { 0x3d3, 10 },
+    { 0x3e7, 10 },
+    { 0x5d, 7 },
+    { 0x21, 6 },
+    { 0x1f, 6 },
+    { 0x23, 6 },
+    { 0x27, 6 },
+    { 0x59, 7 },
+    { 0x64, 7 },
+    { 0xd8, 8 },
+    { 0xdf, 8 },
+    { 0x1d2, 9 },
+    { 0x1e2, 9 },
+    { 0x3dd, 10 },
+    { 0x3ee, 10 },
+    { 0xd1, 8 },
+    { 0x55, 7 },
+    { 0x29, 6 },
+    { 0x56, 7 },
+    { 0x58, 7 },
+    { 0x62, 7 },
+    { 0xce, 8 },
+    { 0xe0, 8 },
+    { 0xe2, 8 },
+    { 0x1da, 9 },
+    { 0x3d4, 10 },
+    { 0x3e3, 10 },
+    { 0x7eb, 11 },
+    { 0x1c9, 9 },
+    { 0x5e, 7 },
+    { 0x5a, 7 },
+    { 0x5c, 7 },
+    { 0x63, 7 },
+    { 0xca, 8 },
+    { 0xda, 8 },
+    { 0x1c7, 9 },
+    { 0x1ca, 9 },
+    { 0x1e0, 9 },
+    { 0x3db, 10 },
+    { 0x3e8, 10 },
+    { 0x7ec, 11 },
+    { 0x1e3, 9 },
+    { 0xd2, 8 },
+    { 0xcb, 8 },
+    { 0xd0, 8 },
+    { 0xd7, 8 },
+    { 0xdb, 8 },
+    { 0x1c6, 9 },
+    { 0x1d5, 9 },
+    { 0x1d8, 9 },
+    { 0x3ca, 10 },
+    { 0x3da, 10 },
+    { 0x7ea, 11 },
+    { 0x7f1, 11 },
+    { 0x1e1, 9 },
+    { 0xd4, 8 },
+    { 0xcf, 8 },
+    { 0xd6, 8 },
+    { 0xde, 8 },
+    { 0xe1, 8 },
+    { 0x1d0, 9 },
+    { 0x1d6, 9 },
+    { 0x3d1, 10 },
+    { 0x3d5, 10 },
+    { 0x3f2, 10 },
+    { 0x7ee, 11 },
+    { 0x7fb, 11 },
+    { 0x3e9, 10 },
+    { 0x1cd, 9 },
+    { 0x1c8, 9 },
+    { 0x1cb, 9 },
+    { 0x1d1, 9 },
+    { 0x1d7, 9 },
+    { 0x1df, 9 },
+    { 0x3cf, 10 },
+    { 0x3e0, 10 },
+    { 0x3ef, 10 },
+    { 0x7e6, 11 },
+    { 0x7f8, 11 },
+    { 0xffa, 12 },
+    { 0x3eb, 10 },
+    { 0x1dd, 9 },
+    { 0x1d3, 9 },
+    { 0x1d9, 9 },
+    { 0x1db, 9 },
+    { 0x3d2, 10 },
+    { 0x3cc, 10 },
+    { 0x3dc, 10 },
+    { 0x3ea, 10 },
+    { 0x7ed, 11 },
+    { 0x7f3, 11 },
+    { 0x7f9, 11 },
+    { 0xff9, 12 },
+    { 0x7f2, 11 },
+    { 0x3ce, 10 },
+    { 0x1e4, 9 },
+    { 0x3cb, 10 },
+    { 0x3d8, 10 },
+    { 0x3d6, 10 },
+    { 0x3e2, 10 },
+    { 0x3e5, 10 },
+    { 0x7e8, 11 },
+    { 0x7f4, 11 },
+    { 0x7f5, 11 },
+    { 0x7f7, 11 },
+    { 0xffb, 12 },
+    { 0x7fa, 11 },
+    { 0x3ec, 10 },
+    { 0x3df, 10 },
+    { 0x3e1, 10 },
+    { 0x3e4, 10 },
+    { 0x3e6, 10 },
+    { 0x3f0, 10 },
+    { 0x7e9, 11 },
+    { 0x7ef, 11 },
+    { 0xff8, 12 },
+    { 0xffe, 12 },
+    { 0xffc, 12 },
+    { 0xfff, 12 },
+};
+
+#define SPECTRUM10_TABLE_SIZE 169u
+
+static const huff_entry_t spectrum11_table[289] = {
+    { 0x0, 4 },
+    { 0x6, 5 },
+    { 0x19, 6 },
+    { 0x3d, 7 },
+    { 0x9c, 8 },
+    { 0xc6, 8 },
+    { 0x1a7, 9 },
+    { 0x390, 10 },
+    { 0x3c2, 10 },
+    { 0x3df, 10 },
+    { 0x7e6, 11 },
+    { 0x7f3, 11 },
+    { 0xffb, 12 },
+    { 0x7ec, 11 },
+    { 0xffa, 12 },
+    { 0xffe, 12 },
+    { 0x38e, 10 },
+    { 0x5, 5 },
+    { 0x1, 4 },
+    { 0x8, 5 },
+    { 0x14, 6 },
+    { 0x37, 7 },
+    { 0x42, 7 },
+    { 0x92, 8 },
+    { 0xaf, 8 },
+    { 0x191, 9 },
+    { 0x1a5, 9 },
+    { 0x1b5, 9 },
+    { 0x39e, 10 },
+    { 0x3c0, 10 },
+    { 0x3a2, 10 },
+    { 0x3cd, 10 },
+    { 0x7d6, 11 },
+    { 0xae, 8 },
+    { 0x17, 6 },
+    { 0x7, 5 },
+    { 0x9, 5 },
+    { 0x18, 6 },
+    { 0x39, 7 },
+    { 0x40, 7 },
+    { 0x8e, 8 },
+    { 0xa3, 8 },
+    { 0xb8, 8 },
+    { 0x199, 9 },
+    { 0x1ac, 9 },
+    { 0x1c1, 9 },
+    { 0x3b1, 10 },
+    { 0x396, 10 },
+    { 0x3be, 10 },
+    { 0x3ca, 10 },
+    { 0x9d, 8 },
+    { 0x3c, 7 },
+    { 0x15, 6 },
+    { 0x16, 6 },
+    { 0x1a, 6 },
+    { 0x3b, 7 },
+    { 0x44, 7 },
+    { 0x91, 8 },
+    { 0xa5, 8 },
+    { 0xbe, 8 },
+    { 0x196, 9 },
+    { 0x1ae, 9 },
+    { 0x1b9, 9 },
+    { 0x3a1, 10 },
+    { 0x391, 10 },
+    { 0x3a5, 10 },
+    { 0x3d5, 10 },
+    { 0x94, 8 },
+    { 0x9a, 8 },
+    { 0x36, 7 },
+    { 0x38, 7 },
+    { 0x3a, 7 },
+    { 0x41, 7 },
+    { 0x8c, 8 },
+    { 0x9b, 8 },
+    { 0xb0, 8 },
+    { 0xc3, 8 },
+    { 0x19e, 9 },
+    { 0x1ab, 9 },
+    { 0x1bc, 9 },
+    { 0x39f, 10 },
+    { 0x38f, 10 },
+    { 0x3a9, 10 },
+    { 0x3cf, 10 },
+    { 0x93, 8 },
+    { 0xbf, 8 },
+    { 0x3e, 7 },
+    { 0x3f, 7 },
+    { 0x43, 7 },
+    { 0x45, 7 },
+    { 0x9e, 8 },
+    { 0xa7, 8 },
+    { 0xb9, 8 },
+    { 0x194, 9 },
+    { 0x1a2, 9 },
+    { 0x1ba, 9 },
+    { 0x1c3, 9 },
+    { 0x3a6, 10 },
+    { 0x3a7, 10 },
+    { 0x3bb, 10 },
+    { 0x3d4, 10 },
+    { 0x9f, 8 },
+    { 0x1a0, 9 },
+    { 0x8f, 8 },
+    { 0x8d, 8 },
+    { 0x90, 8 },
+    { 0x98, 8 },
+    { 0xa6, 8 },
+    { 0xb6, 8 },
+    { 0xc4, 8 },
+    { 0x19f, 9 },
+    { 0x1af, 9 },
+    { 0x1bf, 9 },
+    { 0x399, 10 },
+    { 0x3bf, 10 },
+    { 0x3b4, 10 },
+    { 0x3c9, 10 },
+    { 0x3e7, 10 },
+    { 0xa8, 8 },
+    { 0x1b6, 9 },
+    { 0xab, 8 },
+    { 0xa4, 8 },
+    { 0xaa, 8 },
+    { 0xb2, 8 },
+    { 0xc2, 8 },
+    { 0xc5, 8 },
+    { 0x198, 9 },
+    { 0x1a4, 9 },
+    { 0x1b8, 9 },
+    { 0x38c, 10 },
+    { 0x3a4, 10 },
+    { 0x3c4, 10 },
+    { 0x3c6, 10 },
+    { 0x3dd, 10 },
+    { 0x3e8, 10 },
+    { 0xad, 8 },
+    { 0x3af, 10 },
+    { 0x192, 9 },
+    { 0xbd, 8 },
+    { 0xbc, 8 },
+    { 0x18e, 9 },
+    { 0x197, 9 },
+    { 0x19a, 9 },
+    { 0x1a3, 9 },
+    { 0x1b1, 9 },
+    { 0x38d, 10 },
+    { 0x398, 10 },
+    { 0x3b7, 10 },
+    { 0x3d3, 10 },
+    { 0x3d1, 10 },
+    { 0x3db, 10 },
+    { 0x7dd, 11 },
+    { 0xb4, 8 },
+    { 0x3de, 10 },
+    { 0x1a9, 9 },
+    { 0x19b, 9 },
+    { 0x19c, 9 },
+    { 0x1a1, 9 },
+    { 0x1aa, 9 },
+    { 0x1ad, 9 },
+    { 0x1b3, 9 },
+    { 0x38b, 10 },
+    { 0x3b2, 10 },
+    { 0x3b8, 10 },
+    { 0x3ce, 10 },
+    { 0x3e1, 10 },
+    { 0x3e0, 10 },
+    { 0x7d2, 11 },
+    { 0x7e5, 11 },
+    { 0xb7, 8 },
+    { 0x7e3, 11 },
+    { 0x1bb, 9 },
+    { 0x1a8, 9 },
+    { 0x1a6, 9 },
+    { 0x1b0, 9 },
+    { 0x1b2, 9 },
+    { 0x1b7, 9 },
+    { 0x39b, 10 },
+    { 0x39a, 10 },
+    { 0x3ba, 10 },
+    { 0x3b5, 10 },
+    { 0x3d6, 10 },
+    { 0x7d7, 11 },
+    { 0x3e4, 10 },
+    { 0x7d8, 11 },
+    { 0x7ea, 11 },
+    { 0xba, 8 },
+    { 0x7e8, 11 },
+    { 0x3a0, 10 },
+    { 0x1bd, 9 },
+    { 0x1b4, 9 },
+    { 0x38a, 10 },
+    { 0x1c4, 9 },
+    { 0x392, 10 },
+    { 0x3aa, 10 },
+    { 0x3b0, 10 },
+    { 0x3bc, 10 },
+    { 0x3d7, 10 },
+    { 0x7d4, 11 },
+    { 0x7dc, 11 },
+    { 0x7db, 11 },
+    { 0x7d5, 11 },
+    { 0x7f0, 11 },
+    { 0xc1, 8 },
+    { 0x7fb, 11 },
+    { 0x3c8, 10 },
+    { 0x3a3, 10 },
+    { 0x395, 10 },
+    { 0x39d, 10 },
+    { 0x3ac, 10 },
+    { 0x3ae, 10 },
+    { 0x3c5, 10 },
+    { 0x3d8, 10 },
+    { 0x3e2, 10 },
+    { 0x3e6, 10 },
+    { 0x7e4, 11 },
+    { 0x7e7, 11 },
+    { 0x7e0, 11 },
+    { 0x7e9, 11 },
+    { 0x7f7, 11 },
+    { 0x190, 9 },
+    { 0x7f2, 11 },
+    { 0x393, 10 },
+    { 0x1be, 9 },
+    { 0x1c0, 9 },
+    { 0x394, 10 },
+    { 0x397, 10 },
+    { 0x3ad, 10 },
+    { 0x3c3, 10 },
+    { 0x3c1, 10 },
+    { 0x3d2, 10 },
+    { 0x7da, 11 },
+    { 0x7d9, 11 },
+    { 0x7df, 11 },
+    { 0x7eb, 11 },
+    { 0x7f4, 11 },
+    { 0x7fa, 11 },
+    { 0x195, 9 },
+    { 0x7f8, 11 },
+    { 0x3bd, 10 },
+    { 0x39c, 10 },
+    { 0x3ab, 10 },
+    { 0x3a8, 10 },
+    { 0x3b3, 10 },
+    { 0x3b9, 10 },
+    { 0x3d0, 10 },
+    { 0x3e3, 10 },
+    { 0x3e5, 10 },
+    { 0x7e2, 11 },
+    { 0x7de, 11 },
+    { 0x7ed, 11 },
+    { 0x7f1, 11 },
+    { 0x7f9, 11 },
+    { 0x7fc, 11 },
+    { 0x193, 9 },
+    { 0xffd, 12 },
+    { 0x3dc, 10 },
+    { 0x3b6, 10 },
+    { 0x3c7, 10 },
+    { 0x3cc, 10 },
+    { 0x3cb, 10 },
+    { 0x3d9, 10 },
+    { 0x3da, 10 },
+    { 0x7d3, 11 },
+    { 0x7e1, 11 },
+    { 0x7ee, 11 },
+    { 0x7ef, 11 },
+    { 0x7f5, 11 },
+    { 0x7f6, 11 },
+    { 0xffc, 12 },
+    { 0xfff, 12 },
+    { 0x19d, 9 },
+    { 0x1c2, 9 },
+    { 0xb5, 8 },
+    { 0xa1, 8 },
+    { 0x96, 8 },
+    { 0x97, 8 },
+    { 0x95, 8 },
+    { 0x99, 8 },
+    { 0xa0, 8 },
+    { 0xa2, 8 },
+    { 0xac, 8 },
+    { 0xa9, 8 },
+    { 0xb1, 8 },
+    { 0xb3, 8 },
+    { 0xbb, 8 },
+    { 0xc0, 8 },
+    { 0x18f, 9 },
+    { 0x4, 5 },
+};
+
+#define SPECTRUM11_TABLE_SIZE 289u
+
+#endif
diff --git a/modules/stream_filter/meson.build b/modules/stream_filter/meson.build
index 9f9ae2cd80..a97c2b7bb3 100644
--- a/modules/stream_filter/meson.build
+++ b/modules/stream_filter/meson.build
@@ -45,6 +45,11 @@ vlc_modules += {
     'sources' : files('skiptags.c')
 }

+vlc_modules += {
+    'name' : 'dualmono',
+    'sources' : files('dualmono.c')
+}
+
 aribb25_dep = dependency('aribb25', version:'>= 0.2.6', required: get_option('aribb25'))
 vlc_modules += {
     'name' : 'aribcam',
--
2.39.1

