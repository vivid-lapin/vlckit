From 7339f2f9145f39d57c21e478ca10820b572408ea Mon Sep 17 00:00:00 2001
From: ci7lus <7887955+ci7lus@users.noreply.github.com>
Date: Sat, 14 Feb 2026 17:41:57 +0900
Subject: [PATCH 2/2] chore: Update decoder 3

---
 modules/demux/mpeg/ts_arib.c | 220 +++++++++++++++++++++++++++++------
 1 file changed, 183 insertions(+), 37 deletions(-)

diff --git a/modules/demux/mpeg/ts_arib.c b/modules/demux/mpeg/ts_arib.c
index ccce49ced3..57412a78ff 100644
--- a/modules/demux/mpeg/ts_arib.c
+++ b/modules/demux/mpeg/ts_arib.c
@@ -78,8 +78,8 @@ static const unsigned char CLUT_to_chunks[] = {
     0x00, 0xff, 0xaa, 0x55, 0x00, 0x00, 0x55, 0x00, 0x55, 0x55, 0x00, 0xaa, /* 88-95 */
     0x55, 0x00, 0xff, 0x55, 0x55, 0x00, 0x55, 0x55, 0x55, 0x55, 0x55, 0xaa,
 
-    0x55, 0x55, 0xff, 0x55, 0xaa, 0x00, 0x55, 0xaa, 0x55, 0x55, 0xaa, 0xaa, /* 96-103 */
-    0x55, 0xaa, 0xff, 0x55, 0xff, 0x00, 0x55, 0xff, 0x55, 0x55, 0xff, 0xaa,
+    0x55, 0x55, 0xff, 0x55, 0xaa, 0x00, 0x55, 0xaa, 0x00, 0x55, 0xaa, 0x55, /* 96-103 */
+    0x55, 0xaa, 0xaa, 0x55, 0xaa, 0xff, 0x55, 0xff, 0x00, 0x55, 0xff, 0x55,
 
     0x55, 0xff, 0xff, 0xaa, 0x00, 0x55, 0xaa, 0x00, 0xff, 0xaa, 0x55, 0x00, /* 104-111 */
     0xaa, 0x55, 0x55, 0xaa, 0x55, 0xaa, 0xaa, 0x55, 0xff, 0xaa, 0xaa, 0x55,
@@ -220,6 +220,7 @@ typedef struct
     bool b_2byte[4];
     uint8_t gl, gr;
     uint8_t ss;
+    int rpc_count;
 } arib_state_t;
 
 static void arib_apply_macro( arib_state_t *s, uint8_t m )
@@ -294,8 +295,66 @@ static uint32_t arib_get_ucs( uint16_t code )
     uint8_t row = (uint8_t)(code >> 8);
     uint8_t cell = (uint8_t)(code & 0xFF);
 
-    if( row == 0x7A ) { // Row 90 (0x7A) - Fascicle 1 Table 7-10/7-19/7-20
+    if( row == 0x75 ) { // Row 85 - Kanji Variants
+        if ( cell >= 0x21 && cell <= 0x7E ) {
+            static const uint16_t map[] = {
+                0x3402, 0xE081, 0x4EFD, 0x4EFF, 0x4F9A, 0x4FC9, 0x509C, 0x511E, 0x51BC, 0x351F, 0x5307, 0x5361, /* 1-12 */
+                0x536C, 0x8A79, 0xE084, 0x544D, 0x5496, 0x549C, 0x54A9, 0x550E, 0x554A, 0x5672, 0x56E4, 0x5733, /* 13-24 */
+                0x5734, 0xFA10, 0x5880, 0x59E4, 0x5A23, 0x5A55, 0x5BEC, 0xFA11, 0x37E2, 0x5EAC, 0x5F34, 0x5F45, /* 25-36 */
+                0x5FB7, 0x6017, 0xFA6B, 0x6130, 0x6624, 0x66C8, 0x66D9, 0x66FA, 0x66FB, 0x6852, 0x9FC4, 0x6911, /* 37-48 */
+                0x693B, 0x6A45, 0x6A91, 0x6ADB, 0xE08A, 0xE08B, 0xE08C, 0x6BF1, 0x6CE0, 0x6D2E, 0xFA45, 0x6DBF, /* 49-60 */
+                0x6DCA, 0x6DF8, 0xFA46, 0x6F5E, 0x6FF9, 0x7064, 0xFA6C, 0x242EE, 0x7147, 0x71C1, 0x7200, 0x739F, /* 61-72 */
+                0x73A8, 0x73C9, 0x73D6, 0x741B, 0x7421, 0xFA4A, 0x7426, 0x742A, 0x742C, 0x7439, 0x744B, 0x3EDA  /* 73-84 */
+            };
+            if( cell - 0x21 < (int)(sizeof(map)/sizeof(map[0])) ) return map[cell - 0x21];
+        }
+    } else if ( row == 0x76 ) { // Row 86
+        if ( cell >= 0x21 && cell <= 0x7E ) {
+            static const uint16_t map[] = {
+                0x9FC5, 0x79DA, 0x7A1E, 0x7B7F, 0x7C31, 0x4264, 0x7D8B, 0x7FA1, 0x8118, 0x813A, 0xFA6D, 0x82AE, /* 1-12 */
+                0x845B, 0x84DC, 0x84EC, 0x8559, 0x85CE, 0x8755, 0x87EC, 0x880B, 0x88F5, 0x89D2, 0x8AF6, 0x8DCE, /* 13-24 */
+                0x8FBB, 0x8FF6, 0x90DD, 0x9127, 0x912D, 0x91B2, 0x9233, 0x9288, 0x9321, 0x9348, 0x9592, 0x96DE, /* 25-36 */
+                0x9903, 0x9940, 0x9AD9, 0x9BD6, 0x9DD7, 0x9EB4, 0x9EB5  /* 37-43 */
+            };
+            if( cell - 0x21 < (int)(sizeof(map)/sizeof(map[0])) ) return map[cell - 0x21];
+        }
+    } else if( row == 0x7A ) { // Row 90
         switch( cell ) {
+            case 0x21: return 0x26CC; // accident
+            case 0x22: return 0x26CD; // disabled car
+            case 0x23: return 0x2757; // obstacles
+            case 0x24: return 0x26CF; // under construction
+            case 0x25: return 0x26D0; // icy road
+            case 0x26: return 0x26D1; // maintenance
+            case 0x28: return 0x26D2; // road closed
+            case 0x29: return 0x26D5; // alternate one-way
+            case 0x2A: return 0x26D3; // tire chains
+            case 0x2B: return 0x26D4; // no thoroughfare
+            case 0x30: return 0x1F145; // parking space [P]
+            case 0x34: return 0x26D6; // two-way traffic 1
+            case 0x35: return 0x26D7; // two-way traffic 2
+            case 0x36: return 0x26D8; // lane merge 1
+            case 0x37: return 0x26D9; // lane merge 2
+            case 0x38: return 0x26DA; // drive slow 1
+            case 0x39: return 0x26DB; // drive slow 2
+            case 0x3A: return 0x26DC; // closed entry 1
+            case 0x3B: return 0x26DD; // closed entry 2
+            case 0x3C: return 0x26DE; // closed to large cars 1
+            case 0x3D: return 0x26DF; // closed to large cars 2
+            case 0x3E: return 0x26E0; // restricted entry 1
+            case 0x3F: return 0x26E1; // restricted entry 2
+            case 0x40: return 0x2B55;  // basic speed limit
+            case 0x41: return 0x3248;  // 10km/h
+            case 0x42: return 0x3249;  // 20km/h
+            case 0x43: return 0x324A;  // 30km/h
+            case 0x44: return 0x324B;  // 40km/h
+            case 0x45: return 0x324C;  // 50km/h
+            case 0x46: return 0x324D;  // 60km/h
+            case 0x47: return 0x324E;  // 70km/h
+            case 0x48: return 0x324F;  // 80km/h
+            case 0x4D: return 0x2491;  // time of day (10:00)
+            case 0x4E: return 0x2492;  // time of day (11:00)
+            case 0x4F: return 0x2493;  // time of day (12:00)
             case 0x50: return 0x1F14A; // [HV]
             case 0x51: return 0x1F14B; // [SD]
             case 0x52: return 0x1F13F; // [P]
@@ -329,18 +388,68 @@ static uint32_t arib_get_ucs( uint16_t code )
             case 0x70: return 0x1F224; // [å£°]
             case 0x71: return 0x1F225; // [å¹]
             case 0x72: return 0x1F14F; // [PPV]
-            case 0x73: return 0x3299;  // [ç§˜]
-            case 0x74: return 0x1F200; // [ã»ã‹]
+            case 0x73: return 0x3299;  // (ç§˜)
+            case 0x74: return 0x1F200; // ðŸˆ€
         }
     } else if ( row == 0x7B ) { // Row 91
-        if ( cell == 0x50 ) return 0x1F14C; // [M]
+        switch( cell ) {
+            case 0x21: return 0x26E3;  // [!]
+            case 0x28: return 0x3012;  // ã€’
+            case 0x29: return 0x26E8;  // â›©
+            case 0x2A: return 0x3246;  // [ç¤¾]
+            case 0x2B: return 0x3245;  // [è²¡]
+            case 0x2C: return 0x26E9;  // ðŸ°
+            case 0x2D: return 0x534D;  // å
+            case 0x2E: return 0x26EA;  // â›ª
+            case 0x2F: return 0x26EB;  // â›«
+            case 0x30: return 0x26EC;  // ðŸ—¼
+            case 0x31: return 0x2668;  // â™¨
+            case 0x32: return 0x26ED;  // ðŸ­
+            case 0x33: return 0x26EE;  // âš¡
+            case 0x34: return 0x26EF;  // â›¯
+            case 0x35: return 0x2693;  // âš“
+            case 0x36: return 0x2708;  // âœˆ
+            case 0x37: return 0x26F0;  // â›°
+            case 0x38: return 0x26F1;  // â›±
+            case 0x50: return 0x1F14C; // [M]
+        }
+    } else if ( row == 0x7C ) { // Row 92
+        if ( cell == 0x21 ) return 0x27A1; // âžž
+        if ( cell == 0x22 ) return 0x2B05; // â¬…
+        if ( cell == 0x23 ) return 0x2B06; // â¬†
+        if ( cell == 0x24 ) return 0x2B07; // â¬‡
+        if ( cell == 0x2B ) return 0x33A1; // ãŽ¡
+        if ( cell == 0x2C ) return 0x33A5; // ãŽ¥
+        if ( cell == 0x2D ) return 0x339D; // cm
+        if ( cell == 0x2E ) return 0x33A0; // cm2
+        if ( cell == 0x2F ) return 0x33A4; // cm3
+        if ( cell == 0x37 ) return 0x2113; // l
+        if ( cell == 0x38 ) return 0x338F; // kg
+        if ( cell == 0x39 ) return 0x3390; // Hz
+        if ( cell == 0x3A ) return 0x33CA; // ha
+        if ( cell == 0x3B ) return 0x339E; // km
+        if ( cell == 0x3C ) return 0x33A2; // km2
+        if ( cell == 0x3D ) return 0x33A6; // hPa
+        if ( cell >= 0x4A && cell <= 0x4F ) {
+            static const uint32_t map[] = { 0x3246, 0x3245, 0x1F244, 0x1F245, 0x1F246, 0x1F247 };
+            return map[cell - 0x4A];
+        }
     } else if ( row == 0x7D ) { // Row 93
         if ( cell >= 0x21 && cell <= 0x28 ) return 0x322A + (cell - 0x21); // (æœˆ)-(æ—¥)
-        if ( cell >= 0x29 && cell <= 0x2C ) return 0x337E - (cell - 0x29); // Meiji-Heisei
+        if ( cell == 0x29 ) return 0x337E; // Meiji
+        if ( cell == 0x2A ) return 0x337D; // Taisho
+        if ( cell == 0x2B ) return 0x337C; // Showa
+        if ( cell == 0x2C ) return 0x337B; // Heisei
         if ( cell == 0x41 ) return 0x1F243; // [å·¦]
     } else if ( row == 0x7E ) { // Row 94
         if ( cell >= 0x21 && cell <= 0x2C ) return 0x2160 + (cell - 0x21); // I-XII
-        if ( cell >= 0x2D && cell <= 0x40 ) return 0x2460 + (cell - 0x2D); // (1)-(20)
+        if ( cell >= 0x2D && cell <= 0x30 ) return 0x2470 + (cell - 0x2D); // 17-20 in circle
+        if ( cell >= 0x31 && cell <= 0x3C ) return 0x2474 + (cell - 0x31); // (1)-(12)
+        if ( cell >= 0x3D && cell <= 0x46 ) return 0x3251 + (cell - 0x3D); // 21-30 in circle
+        if ( cell >= 0x51 && cell <= 0x59 ) return 0x2460 + (cell - 0x51); // 1-9 in circle
+        if ( cell >= 0x5A && cell <= 0x5F ) return 0x2469 + (cell - 0x5A); // 10-15 in circle
+        if ( cell == 0x60 ) return 0x246F; // 16 in circle
+        if ( cell == 0x6D ) return 0x325F; // 31 in circle
     }
     return 0;
 }
@@ -350,9 +459,10 @@ char * ts_arib_Decode_B24( const uint8_t *p_data, size_t i_data )
     if( i_data == 0 ) return NULL;
 
     arib_state_t s;
+    memset( &s, 0, sizeof(s) );
     arib_apply_macro( &s, 0x70 ); // SI default initialization
 
-    char *p_out = malloc( i_data * 4 + 1 );
+    char *p_out = malloc( i_data * 10 + 1 ); // Larger buffer for RPC repeats
     if( !p_out ) return NULL;
     char *p_dst = p_out;
 
@@ -404,6 +514,19 @@ char * ts_arib_Decode_B24( const uint8_t *p_data, size_t i_data )
         if( c >= 0x80 && c <= 0x9F ) {
             if( c == 0x8E ) s.ss = 2; // SS2
             else if( c == 0x8F ) s.ss = 3; // SS3
+            else if( c == 0x98 ) { // RPC: Repeat Character
+                i++;
+                if( i < i_data ) {
+                    s.rpc_count = (p_data[i] & 0x3F);
+                    if( s.rpc_count == 0 ) s.rpc_count = 1;
+                    i++;
+                }
+                continue;
+            }
+            else if( c == 0x8B || (c >= 0x90 && c <= 0x95) || c == 0x97 ) {
+                // Codes with 1-byte parameter
+                i++;
+            }
             else if( c == 0x9B ) { // CSI
                 i++;
                 while( i < i_data && (p_data[i] < 0x40 || p_data[i] > 0x7E) ) i++;
@@ -418,7 +541,7 @@ char * ts_arib_Decode_B24( const uint8_t *p_data, size_t i_data )
             else if( c == 0x0D || c == 0x0A ) *p_dst++ = '\n'; // APR / APD
             i++; continue;
         }
-        
+
         if( (c & 0x7F) == 0x20 ) { *p_dst++ = ' '; i++; continue; }
 
         /* Character invocation */
@@ -433,45 +556,68 @@ char * ts_arib_Decode_B24( const uint8_t *p_data, size_t i_data )
             i += 2;
         } else i++;
 
-        /* Decode */
+        char char_buf[16];
+        size_t written_len = 0;
         uint32_t sym = arib_get_ucs( code );
         if( sym ) {
-            p_dst += write_utf8( p_dst, sym );
+            written_len = write_utf8( char_buf, sym );
         } else if( set == 0x42 || set == 0x39 || set == 0x3A ) { // Kanji / JIS X 0213
             uint8_t euc[3] = { (uint8_t)((code >> 8) | 0x80), (uint8_t)((code & 0xFF) | 0x80), 0 };
-            char *utf8 = FromCharset( "EUC-JP", (char *)euc, 2 );
+            char *utf8 = FromCharset( "EUC-JP", (const char *)euc, 2 );
             if( utf8 ) {
-                size_t len = strlen(utf8);
-                memcpy( p_dst, utf8, len );
-                p_dst += len;
+                written_len = strlen(utf8);
+                if( written_len < sizeof(char_buf) ) memcpy( char_buf, utf8, written_len );
+                else written_len = 0;
                 free( utf8 );
             }
         } else if( set == 0x4A || set == 0x37 ) { // Alphanumeric / Prop. Alnum
-            if( code == 0x5C ) p_dst += write_utf8( p_dst, 0x00A5 ); // Yen
-            else if( code == 0x7E ) p_dst += write_utf8( p_dst, 0x203E ); // Overline
-            else *p_dst++ = (char)code;
-        } else if( set == 0x31 || set == 0x39 || set == 0x49 ) { // Katakana
-            if( code >= 0x21 && code <= 0x73 ) p_dst += write_utf8( p_dst, 0x30A1 + (uint32_t)(code - 0x21) );
+            if( code == 0x5C ) written_len = write_utf8( char_buf, 0x00A5 ); // Yen
+            else if( code == 0x7E ) written_len = write_utf8( char_buf, 0x203E ); // Overline
+            else { char_buf[0] = (char)code; written_len = 1; }
+        } else if( set == 0x31 || set == 0x39 ) { // Katakana / Prop. Katakana
+            if( code >= 0x21 && code <= 0x76 ) written_len = write_utf8( char_buf, 0x30A1 + (uint32_t)(code - 0x21) );
+            else switch( code ) {
+                case 0x77: written_len = write_utf8( char_buf, 0x30FD ); break; // ãƒ½
+                case 0x78: written_len = write_utf8( char_buf, 0x30FE ); break; // ãƒ¾
+                case 0x79: written_len = write_utf8( char_buf, 0x30FC ); break; // ãƒ¼
+                case 0x7A: written_len = write_utf8( char_buf, 0x3002 ); break; // ã€‚
+                case 0x7B: written_len = write_utf8( char_buf, 0x300C ); break; // ã€Œ
+                case 0x7C: written_len = write_utf8( char_buf, 0x300D ); break; // ã€
+                case 0x7D: written_len = write_utf8( char_buf, 0x3001 ); break; // ã€
+                case 0x7E: written_len = write_utf8( char_buf, 0x30FB ); break; // ãƒ»
+            }
+        } else if( set == 0x30 || set == 0x38 ) { // Hiragana / Prop. Hiragana
+            if( code >= 0x21 && code <= 0x73 ) written_len = write_utf8( char_buf, 0x3041 + (uint32_t)(code - 0x21) );
             else switch( code ) {
-                case 0x77: p_dst += write_utf8( p_dst, 0x30FC ); break; // ãƒ¼
-                case 0x78: p_dst += write_utf8( p_dst, 0x3002 ); break; // ã€‚
-                case 0x79: p_dst += write_utf8( p_dst, 0x300C ); break; // ã€Œ
-                case 0x7A: p_dst += write_utf8( p_dst, 0x300D ); break; // ã€
-                case 0x7B: p_dst += write_utf8( p_dst, 0x3001 ); break; // ã€
-                case 0x7C: p_dst += write_utf8( p_dst, 0x30FB ); break; // ãƒ»
+                case 0x74: written_len = write_utf8( char_buf, 0x3094 ); break; // ã‚”
+                case 0x77: written_len = write_utf8( char_buf, 0x30FC ); break; // ãƒ¼
+                case 0x78: written_len = write_utf8( char_buf, 0x3002 ); break; // ã€‚
+                case 0x79: written_len = write_utf8( char_buf, 0x300C ); break; // ã€Œ
+                case 0x7A: written_len = write_utf8( char_buf, 0x300D ); break; // ã€
+                case 0x7B: written_len = write_utf8( char_buf, 0x3001 ); break; // ã€
+                case 0x7C: written_len = write_utf8( char_buf, 0x30FB ); break; // ãƒ»
             }
-        } else if( set == 0x30 || set == 0x38 ) { // Hiragana
-            if( code >= 0x21 && code <= 0x73 ) p_dst += write_utf8( p_dst, 0x3041 + (uint32_t)(code - 0x21) );
+        } else if( set == 0x49 ) { // JIS X 0201 Katakana
+            if( code >= 0x27 && code <= 0x5F ) written_len = write_utf8( char_buf, 0x30A1 + (uint32_t)(code - 0x27) );
             else switch( code ) {
-                case 0x77: p_dst += write_utf8( p_dst, 0x30FC ); break; // ãƒ¼
-                case 0x78: p_dst += write_utf8( p_dst, 0x3002 ); break; // ã€‚
-                case 0x79: p_dst += write_utf8( p_dst, 0x300C ); break; // ã€Œ
-                case 0x7A: p_dst += write_utf8( p_dst, 0x300D ); break; // ã€
-                case 0x7B: p_dst += write_utf8( p_dst, 0x3001 ); break; // ã€
-                case 0x7C: p_dst += write_utf8( p_dst, 0x30FB ); break; // ãƒ»
+                case 0x21: written_len = write_utf8( char_buf, 0x3002 ); break; // ã€‚
+                case 0x22: written_len = write_utf8( char_buf, 0x300C ); break; // ã€Œ
+                case 0x23: written_len = write_utf8( char_buf, 0x300D ); break; // ã€
+                case 0x24: written_len = write_utf8( char_buf, 0x3001 ); break; // ã€
+                case 0x25: written_len = write_utf8( char_buf, 0x30FB ); break; // ãƒ»
+                case 0x26: written_len = write_utf8( char_buf, 0x30F2 ); break; // ãƒ²
+            }
+        } else if( set == 0x3B ) { // Additional Symbols
+            char_buf[0] = '?'; written_len = 1;
+        }
+
+        if( written_len > 0 ) {
+            int count = (s.rpc_count > 0) ? s.rpc_count : 1;
+            for( int j = 0; j < count; j++ ) {
+                memcpy( p_dst, char_buf, written_len );
+                p_dst += written_len;
             }
-        } else if( set == 0x3B ) { // Additional Symbols (not found in helper)
-            *p_dst++ = '?';
+            s.rpc_count = 0;
         }
     }
 
-- 
2.39.1

