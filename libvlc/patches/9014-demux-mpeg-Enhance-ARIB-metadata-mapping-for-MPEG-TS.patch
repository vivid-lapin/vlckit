From faaf08504457534168e111fefcd5542c2a73688b Mon Sep 17 00:00:00 2001
From: ci7lus <7887955+ci7lus@users.noreply.github.com>
Date: Thu, 19 Feb 2026 02:08:01 +0900
Subject: [PATCH] demux/mpeg: Enhance ARIB metadata mapping for MPEG-TS with
 additional fields

---
 modules/demux/mpeg/ts_si.c | 263 +++++++++++++++++++++++++------------
 src/input/es_out.c         | 142 +++++++++++++++++++-
 2 files changed, 312 insertions(+), 93 deletions(-)

diff --git a/modules/demux/mpeg/ts_si.c b/modules/demux/mpeg/ts_si.c
index a52efc85b6..89eeee6ddf 100644
--- a/modules/demux/mpeg/ts_si.c
+++ b/modules/demux/mpeg/ts_si.c
@@ -281,6 +281,10 @@ static void SDTCallBack( void *opaque, dvbpsi_sdt_t *p_sdt )
                     if( pD->i_service_type >= 0x01 && pD->i_service_type <= 0x10 )
                         psz_type = ppsz_type[pD->i_service_type];
                 }
+                if (p_sys->standard == TS_STANDARD_ARIB)
+                {
+                    vlc_meta_SetExtra( p_meta, "ServiceName", str2 ? str2 : str1 );
+                }
                 free( str1 );
                 free( str2 );
             }
@@ -391,6 +395,7 @@ static void TDTCallBack( void *opaque, dvbpsi_tot_t *p_tdt )
 {
     demux_t            *p_demux = opaque;
     demux_sys_t        *p_sys = p_demux->p_sys;
+    const bool          b_first_time_meta = ( p_sys->i_network_time_update == 0 );


     p_sys->i_network_time = EITConvertStartTime( p_tdt->i_utc_time );
@@ -412,86 +417,161 @@ static void TDTCallBack( void *opaque, dvbpsi_tot_t *p_tdt )
     dvbpsi_tot_delete(p_tdt);

     es_out_Control( p_demux->out, ES_OUT_SET_EPG_TIME, (int64_t) p_sys->i_network_time );
+
+    if( b_first_time_meta )
+    {
+        char psz_first_network_time[32];
+
+        if( snprintf( psz_first_network_time, sizeof(psz_first_network_time),
+                      "%"PRId64, (int64_t)p_sys->i_network_time ) > 0 )
+        {
+            vlc_meta_t *p_meta = vlc_meta_New();
+            if( p_meta )
+            {
+                vlc_meta_SetExtra( p_meta, "FirstNetworkTime", psz_first_network_time );
+                es_out_Control( p_demux->out, ES_OUT_SET_GROUP_META, -1, p_meta );
+                vlc_meta_Delete( p_meta );
+            }
+        }
+    }
 }

-static void EITExtractDrDescItems( demux_t *p_demux, const dvbpsi_extended_event_dr_t *pE,
-                                   vlc_epg_event_t *p_evt )
+typedef struct
 {
-    demux_sys_t *p_sys = p_demux->p_sys;
+    uint8_t *p_key;
+    size_t i_key;
+    uint8_t *p_value;
+    size_t i_value;
+} eit_raw_desc_item_t;
+
+static bool EITRawAppend( uint8_t **pp_dst, size_t *pi_dst,
+                          const uint8_t *p_src, size_t i_src )
+{
+    if( i_src == 0 )
+        return true;
+    if( *pi_dst > SIZE_MAX - i_src )
+        return false;

-    if( pE->i_entry_count )
+    uint8_t *p_realloc = realloc( *pp_dst, *pi_dst + i_src );
+    if( !p_realloc )
+        return false;
+
+    memcpy( &p_realloc[*pi_dst], p_src, i_src );
+    *pp_dst = p_realloc;
+    *pi_dst += i_src;
+    return true;
+}
+
+static void EITRawDescItemsDelete( eit_raw_desc_item_t *p_items, int i_items )
+{
+    for( int i = 0; i < i_items; i++ )
     {
-        char **ppsz_prev = NULL;
-        /* Continued items from previous descriptor (ARIB) */
-        if( p_evt->i_description_items > 0 )
-            ppsz_prev = &p_evt->description_items[p_evt->i_description_items - 1].psz_value;
+        free( p_items[i].p_key );
+        free( p_items[i].p_value );
+    }
+    free( p_items );
+}

+static void EITExtractDrDescItemsRaw( const dvbpsi_extended_event_dr_t *pE,
+                                      eit_raw_desc_item_t **pp_items, int *pi_items,
+                                      int *pi_prev_item )
+{
+    if( pE->i_entry_count )
+    {
         for( int i = 0; i < pE->i_entry_count; i++ )
         {
-            char *psz_key = NULL;
-            /* Continued items have NULL key */
             const bool b_appending = ( pE->i_item_description_length[i] == 0 );
-            if( !b_appending )
+            if( b_appending )
             {
-                void *p_realloc = NULL;
-                if( (size_t)p_evt->i_description_items < SIZE_MAX / sizeof(*p_evt->description_items) )
-                {
-                    p_realloc = realloc( p_evt->description_items,
-                                        (p_evt->i_description_items + 1) *
-                                         sizeof(*p_evt->description_items) );
-                }
+                /* Continued items from previous descriptor (ARIB) */
+                if( *pi_prev_item < 0 || *pi_prev_item >= *pi_items )
+                    continue;
+
+                if( !EITRawAppend( &(*pp_items)[*pi_prev_item].p_value,
+                                   &(*pp_items)[*pi_prev_item].i_value,
+                                   pE->i_item[i], pE->i_item_length[i] ) )
+                    *pi_prev_item = -1;
+            }
+            else
+            {
+                if( *pi_items >= INT_MAX ||
+                    (size_t)*pi_items >= SIZE_MAX / sizeof(**pp_items) )
+                    break;
+
+                eit_raw_desc_item_t *p_realloc =
+                    realloc( *pp_items, (*pi_items + 1) * sizeof(**pp_items) );
                 if( !p_realloc )
-                {
-                    free( psz_key );
                     break;
-                }
-                p_evt->description_items = p_realloc;

-                psz_key = EITConvertToUTF8( p_demux,
-                                            pE->i_item_description[i],
-                                            pE->i_item_description_length[i],
-                                            p_sys->b_broken_charset );
-                if( !psz_key )
+                *pp_items = p_realloc;
+                (*pp_items)[*pi_items].p_key = NULL;
+                (*pp_items)[*pi_items].i_key = 0;
+                (*pp_items)[*pi_items].p_value = NULL;
+                (*pp_items)[*pi_items].i_value = 0;
+
+                if( !EITRawAppend( &(*pp_items)[*pi_items].p_key,
+                                   &(*pp_items)[*pi_items].i_key,
+                                   pE->i_item_description[i],
+                                   pE->i_item_description_length[i] ) ||
+                    !EITRawAppend( &(*pp_items)[*pi_items].p_value,
+                                   &(*pp_items)[*pi_items].i_value,
+                                   pE->i_item[i], pE->i_item_length[i] ) )
                 {
-                    ppsz_prev = NULL;
-                    continue;
+                    free( (*pp_items)[*pi_items].p_key );
+                    free( (*pp_items)[*pi_items].p_value );
+                    break;
                 }
-            }
-            else if( ppsz_prev == NULL )
-                continue;

-            char *psz_itm = EITConvertToUTF8( p_demux,
-                                              pE->i_item[i], pE->i_item_length[i],
-                                              p_sys->b_broken_charset );
-            if( !psz_itm )
-            {
-                free( psz_key );
-                ppsz_prev = NULL;
-                continue;
+                *pi_prev_item = *pi_items;
+                (*pi_items)++;
             }
+        }
+    }
+}

-            msg_Dbg( p_demux, "       - desc='%s' item='%s'",
-                     psz_key ? psz_key : "(null)", psz_itm );
-            if( b_appending )
-            {
-                /* Continued items */
-                size_t i_total = strlen(*ppsz_prev) + strlen(psz_itm) + 1;
-                char *psz_realloc = realloc( *ppsz_prev, i_total );
-                if( psz_realloc )
-                {
-                    *ppsz_prev = psz_realloc;
-                    strcat( *ppsz_prev, psz_itm );
-                }
-                free( psz_itm );
-            }
-            else
-            {
-                p_evt->description_items[p_evt->i_description_items].psz_key = psz_key;
-                p_evt->description_items[p_evt->i_description_items].psz_value = psz_itm;
-                ppsz_prev = &p_evt->description_items[p_evt->i_description_items].psz_value;
-                p_evt->i_description_items++;
-            }
+static void EITAttachDecodedRawDescItems( demux_t *p_demux, vlc_epg_event_t *p_evt,
+                                          const eit_raw_desc_item_t *p_items, int i_items )
+{
+    demux_sys_t *p_sys = p_demux->p_sys;
+
+    for( int i = 0; i < i_items; i++ )
+    {
+        char *psz_key = EITConvertToUTF8( p_demux, p_items[i].p_key, p_items[i].i_key,
+                                          p_sys->b_broken_charset );
+        char *psz_val = EITConvertToUTF8( p_demux, p_items[i].p_value, p_items[i].i_value,
+                                          p_sys->b_broken_charset );
+
+        if( !psz_key || !psz_val )
+        {
+            free( psz_key );
+            free( psz_val );
+            continue;
+        }
+
+        if( p_evt->i_description_items >= INT_MAX ||
+            (size_t)p_evt->i_description_items >= SIZE_MAX / sizeof(*p_evt->description_items) )
+        {
+            free( psz_key );
+            free( psz_val );
+            break;
+        }
+
+        void *p_realloc = realloc( p_evt->description_items,
+                                   (p_evt->i_description_items + 1) *
+                                   sizeof(*p_evt->description_items) );
+        if( !p_realloc )
+        {
+            free( psz_key );
+            free( psz_val );
+            break;
         }
+
+        p_evt->description_items = p_realloc;
+        p_evt->description_items[p_evt->i_description_items].psz_key = psz_key;
+        p_evt->description_items[p_evt->i_description_items].psz_value = psz_val;
+        p_evt->i_description_items++;
+
+        msg_Dbg( p_demux, "       - desc='%s' item='%s'", psz_key, psz_val );
     }
 }

@@ -535,6 +615,11 @@ static void EITCallBack( void *opaque, dvbpsi_eit_t *p_eit )
         dvbpsi_descriptor_t *p_dr;
         int64_t i_start;
         int i_duration;
+        uint8_t *p_extended_text_raw = NULL;
+        size_t i_extended_text_raw = 0;
+        eit_raw_desc_item_t *p_desc_items_raw = NULL;
+        int i_desc_items_raw = 0;
+        int i_prev_desc_item = -1;

         i_start = EITConvertStartTime( p_evt->i_start_time );
         SI_DEBUG_TIMESHIFT(i_start);
@@ -606,32 +691,12 @@ static void EITCallBack( void *opaque, dvbpsi_eit_t *p_eit )

                     if( pE->i_text_length > 0 )
                     {
-                        char *psz_text = EITConvertToUTF8( p_demux,
-                                                           pE->i_text, pE->i_text_length,
-                                                           p_sys->b_broken_charset );
-                        if( psz_text )
-                        {
-                            msg_Dbg( p_demux, "       - text='%s'", psz_text );
-
-                            if( p_epgevt->psz_description )
-                            {
-                                size_t i_total = strlen( p_epgevt->psz_description ) + strlen( psz_text ) + 1;
-                                char *psz_realloc = realloc( p_epgevt->psz_description, i_total );
-                                if( psz_realloc )
-                                {
-                                    p_epgevt->psz_description = psz_realloc;
-                                    strcat( psz_realloc, psz_text );
-                                }
-                                free( psz_text );
-                            }
-                            else
-                            {
-                                p_epgevt->psz_description = psz_text;
-                            }
-                        }
+                        EITRawAppend( &p_extended_text_raw, &i_extended_text_raw,
+                                      pE->i_text, pE->i_text_length );
                     }

-                    EITExtractDrDescItems( p_demux, pE, p_epgevt );
+                    EITExtractDrDescItemsRaw( pE, &p_desc_items_raw,
+                                              &i_desc_items_raw, &i_prev_desc_item );
                 }
             }
                 break;
@@ -664,6 +729,22 @@ static void EITCallBack( void *opaque, dvbpsi_eit_t *p_eit )
             }
         }

+        if( i_extended_text_raw > 0 )
+        {
+            char *psz_text = EITConvertToUTF8( p_demux, p_extended_text_raw,
+                                               i_extended_text_raw, p_sys->b_broken_charset );
+            if( psz_text )
+            {
+                msg_Dbg( p_demux, "       - text='%s'", psz_text );
+                free( p_epgevt->psz_description );
+                p_epgevt->psz_description = psz_text;
+            }
+        }
+
+        EITAttachDecodedRawDescItems( p_demux, p_epgevt, p_desc_items_raw, i_desc_items_raw );
+        free( p_extended_text_raw );
+        EITRawDescItemsDelete( p_desc_items_raw, i_desc_items_raw );
+
         switch ( p_evt->i_running_status )
         {
             case TS_SI_RUNSTATUS_RUNNING:
@@ -687,8 +768,18 @@ static void EITCallBack( void *opaque, dvbpsi_eit_t *p_eit )
     if( i_runevt || i_fallbackevt )
         vlc_epg_SetCurrent( p_epg, (i_runevt) ? i_runevt : i_fallbackevt );

+    /* For EIT p/f (table_id 0x4E), if no current event was determined
+       (e.g. ARIB where running_status is always 0 and TDT may not have
+       arrived yet), use the first event as the present event per spec */
+    if( !i_runevt && !i_fallbackevt && p_eit->i_table_id == 0x4e &&
+        p_epg->i_event > 0 )
+    {
+        vlc_epg_SetCurrent( p_epg, p_epg->pp_event[0]->i_start );
+    }
+
     if( p_epg->i_event > 0 )
     {
+        p_epg->b_present = (p_eit->i_table_id == 0x4e);
         if( p_epg->b_present && p_epg->p_current )
         {
             ts_pat_t *p_pat = ts_pid_Get(&p_sys->pids, 0)->u.p_pat;
@@ -698,8 +789,8 @@ static void EITCallBack( void *opaque, dvbpsi_eit_t *p_eit )
                 p_pmt->eit.i_event_start = p_epg->p_current->i_start;
                 p_pmt->eit.i_event_length = p_epg->p_current->i_duration;
             }
+
         }
-        p_epg->b_present = (p_eit->i_table_id == 0x4e);
         es_out_Control( p_demux->out, ES_OUT_SET_GROUP_EPG, p_eit->i_extension, p_epg );
     }
     vlc_epg_Delete( p_epg );
diff --git a/src/input/es_out.c b/src/input/es_out.c
index d341adac71..9b71981d84 100644
--- a/src/input/es_out.c
+++ b/src/input/es_out.c
@@ -1848,7 +1848,8 @@ static void EsOutProgramMeta(es_out_sys_t *p_sys, input_source_t *source,
     /* Check against empty meta data (empty for what we handle) */
     if( !vlc_meta_Get( p_meta, vlc_meta_Title) &&
         !vlc_meta_Get( p_meta, vlc_meta_ESNowPlaying) &&
-        !vlc_meta_Get( p_meta, vlc_meta_Publisher) )
+        !vlc_meta_Get( p_meta, vlc_meta_Publisher) &&
+        vlc_meta_GetExtraCount( p_meta ) == 0 )
     {
         return;
     }
@@ -1978,6 +1979,49 @@ static void EsOutProgramEpgEvent(es_out_sys_t *p_sys, input_source_t *source,
     input_item_SetEpgEvent( p_item, p_event );
 }

+#define ARIB_META_EXTRA_PREFIX "PresentEventItemDescriptor:"
+
+static bool EsOutMetaExtraHasPrefix(const char *psz_name, const char *psz_prefix)
+{
+    return psz_name != NULL && psz_prefix != NULL &&
+           !strncmp(psz_name, psz_prefix, strlen(psz_prefix));
+}
+
+static void EsOutMetaClearPrefixedExtras(vlc_meta_t *p_meta, const char *psz_prefix)
+{
+    if( !p_meta )
+        return;
+
+    char **ppsz_names = vlc_meta_CopyExtraNames( p_meta );
+    if( !ppsz_names )
+        return;
+
+    for( int i = 0; ppsz_names[i] != NULL; i++ )
+    {
+        if( EsOutMetaExtraHasPrefix( ppsz_names[i], psz_prefix ) )
+            vlc_meta_SetExtra( p_meta, ppsz_names[i], NULL );
+        free( ppsz_names[i] );
+    }
+    free( ppsz_names );
+}
+
+static void EsOutInputItemClearPrefixedExtras(input_item_t *p_item, const char *psz_prefix)
+{
+    char **ppsz_names = NULL;
+    unsigned i_count = input_item_GetMetaExtraNames( p_item, &ppsz_names );
+    VLC_UNUSED(i_count);
+    if( !ppsz_names )
+        return;
+
+    for( int i = 0; ppsz_names[i] != NULL; i++ )
+    {
+        if( EsOutMetaExtraHasPrefix( ppsz_names[i], psz_prefix ) )
+            input_item_SetMetaExtra( p_item, ppsz_names[i], NULL );
+        free( ppsz_names[i] );
+    }
+    free( ppsz_names );
+}
+
 static void EsOutProgramEpg(es_out_sys_t *p_sys, input_source_t *source,
                             int i_group, const vlc_epg_t *p_epg)
 {
@@ -2015,26 +2059,110 @@ static void EsOutProgramEpg(es_out_sys_t *p_sys, input_source_t *source,
         vlc_meta_SetNowPlaying( p_pgrm->p_meta, NULL );
     }

+    const vlc_epg_event_t *p_current = NULL;
     vlc_mutex_lock( &p_item->lock );
+    if( p_item->p_epg_table != NULL &&
+        p_item->p_epg_table->b_present &&
+        p_item->p_epg_table->i_source_id == p_pgrm->i_id )
+    {
+        p_current = p_item->p_epg_table->p_current;
+    }
+    else
+    {
     for( int i = 0; i < p_item->i_epg; i++ )
     {
         const vlc_epg_t *p_tmp = p_item->pp_epg[i];

         if( p_tmp->b_present && p_tmp->i_source_id == p_pgrm->i_id )
         {
-            const char *psz_name = ( p_tmp->p_current ) ? p_tmp->p_current->psz_name : NULL;
-            if( !p_pgrm->p_meta )
-                p_pgrm->p_meta = vlc_meta_New();
-            if( p_pgrm->p_meta )
-                vlc_meta_Set( p_pgrm->p_meta, vlc_meta_ESNowPlaying, psz_name );
-            break;
+                p_current = p_tmp->p_current;
+                break;
+            }
         }
     }
     vlc_mutex_unlock( &p_item->lock );

+    const char *psz_name = ( p_current ) ? p_current->psz_name : NULL;
+    const char *psz_short_desc = ( p_current ) ? p_current->psz_short_description : NULL;
+    if( !p_pgrm->p_meta )
+        p_pgrm->p_meta = vlc_meta_New();
+    if( p_pgrm->p_meta )
+    {
+        vlc_meta_Set( p_pgrm->p_meta, vlc_meta_ESNowPlaying, psz_name );
+
+        char psz_event_start[32];
+        char psz_event_duration[32];
+
+        vlc_meta_SetExtra( p_pgrm->p_meta, "PresentEventName", psz_name );
+        vlc_meta_SetExtra( p_pgrm->p_meta, "PresentEventShortDescriptor", psz_short_desc );
+        if( p_current != NULL )
+        {
+            snprintf( psz_event_start, sizeof(psz_event_start),
+                      "%"PRId64, p_current->i_start );
+            snprintf( psz_event_duration, sizeof(psz_event_duration),
+                      "%"PRIu32, p_current->i_duration );
+            vlc_meta_SetExtra( p_pgrm->p_meta, "PresentEventStartAt", psz_event_start );
+            vlc_meta_SetExtra( p_pgrm->p_meta, "PresentEventDuration", psz_event_duration );
+        }
+        else
+        {
+            vlc_meta_SetExtra( p_pgrm->p_meta, "PresentEventStartAt", NULL );
+            vlc_meta_SetExtra( p_pgrm->p_meta, "PresentEventDuration", NULL );
+    }
+        vlc_meta_SetDate( p_pgrm->p_meta, NULL );
+
+        EsOutMetaClearPrefixedExtras( p_pgrm->p_meta, ARIB_META_EXTRA_PREFIX );
+        if( p_current != NULL )
+        {
+            for( int j = 0; j < p_current->i_description_items; j++ )
+            {
+                const char *psz_key = p_current->description_items[j].psz_key;
+                const char *psz_value = p_current->description_items[j].psz_value;
+                char *psz_extra_name = NULL;
+
+                if( psz_key == NULL || psz_value == NULL || *psz_key == '\0' )
+                    continue;
+                if( asprintf( &psz_extra_name, ARIB_META_EXTRA_PREFIX "%s", psz_key ) < 0 )
+                    continue;
+                vlc_meta_SetExtra( p_pgrm->p_meta, psz_extra_name, psz_value );
+                free( psz_extra_name );
+            }
+        }
+    }
+
     /* Update selected program input info */
     if( p_pgrm == p_sys->p_pgrm )
     {
+        const char *psz_service_name = p_pgrm->p_meta ?
+                                       vlc_meta_GetExtra( p_pgrm->p_meta, "ServiceName" ) : NULL;
+        input_item_SetMetaExtra( input_priv(p_input)->p_item, "ServiceName", psz_service_name );
+        input_item_SetMetaExtra( input_priv(p_input)->p_item, "PresentEventName",
+                                 p_pgrm->p_meta ? vlc_meta_GetExtra( p_pgrm->p_meta, "PresentEventName" ) : NULL );
+        input_item_SetMetaExtra( input_priv(p_input)->p_item, "PresentEventShortDescriptor",
+                                 p_pgrm->p_meta ? vlc_meta_GetExtra( p_pgrm->p_meta, "PresentEventShortDescriptor" ) : NULL );
+        input_item_SetMetaExtra( input_priv(p_input)->p_item, "PresentEventStartAt",
+                                 p_pgrm->p_meta ? vlc_meta_GetExtra( p_pgrm->p_meta, "PresentEventStartAt" ) : NULL );
+        input_item_SetMetaExtra( input_priv(p_input)->p_item, "PresentEventDuration",
+                                 p_pgrm->p_meta ? vlc_meta_GetExtra( p_pgrm->p_meta, "PresentEventDuration" ) : NULL );
+
+        EsOutInputItemClearPrefixedExtras( input_priv(p_input)->p_item, ARIB_META_EXTRA_PREFIX );
+        if( p_pgrm->p_meta )
+        {
+            char **ppsz_extra_names = vlc_meta_CopyExtraNames( p_pgrm->p_meta );
+            if( ppsz_extra_names )
+            {
+                for( int i = 0; ppsz_extra_names[i] != NULL; i++ )
+                {
+                    if( EsOutMetaExtraHasPrefix( ppsz_extra_names[i], ARIB_META_EXTRA_PREFIX ) )
+                    {
+                        input_item_SetMetaExtra( input_priv(p_input)->p_item, ppsz_extra_names[i],
+                                                 vlc_meta_GetExtra( p_pgrm->p_meta, ppsz_extra_names[i] ) );
+                    }
+                    free( ppsz_extra_names[i] );
+                }
+                free( ppsz_extra_names );
+            }
+        }
         const char *psz_nowplaying = p_pgrm->p_meta ?
                                      vlc_meta_Get( p_pgrm->p_meta, vlc_meta_ESNowPlaying ) : NULL;

--
2.39.1

